[{"title":"day2-学习总结","url":"/2022/02/27/day2-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>摘要: </p>\n<p>①string和vector的基础使用</p>\n<p>②迭代器初识</p>\n<p>③循环条件问题</p>\n<span id=\"more\"></span>\n<h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::string;</span><br></pre></td></tr></table></figure>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">string s = <span class=\"string\">&quot;value&quot;</span>;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">&quot;value&quot;</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"string\">&quot;c&quot;</span>)</span></span>;<span class=\"comment\">//&quot;ccc&quot;</span></span><br></pre></td></tr></table></figure>\n<p>1称之为拷贝初始化,2,3为直接初始化</p>\n<h2 id=\"string操作\"><a href=\"#string操作\" class=\"headerlink\" title=\"string操作\"></a>string操作</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">&quot;value&quot;</span>)</span></span>;</span><br><span class=\"line\">os &lt;&lt; s;</span><br><span class=\"line\">is &gt;&gt; s;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(is, s);</span><br><span class=\"line\">s.<span class=\"built_in\">empty</span>();<span class=\"comment\">//true or false</span></span><br><span class=\"line\">s.<span class=\"built_in\">size</span>();<span class=\"comment\">//注意他返回一个无符号类型std::size_type</span></span><br><span class=\"line\">s[n];<span class=\"comment\">//0~n-1</span></span><br><span class=\"line\">s2 = s;</span><br><span class=\"line\">s3 = s + s2;<span class=\"comment\">//得到拼接后的结果</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(s2 == s);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(s2 != s3);</span><br><span class=\"line\"><span class=\"comment\">//&lt;,&lt;=,&gt;,&gt;= 按照字典中的顺序比较</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"读写\"><a href=\"#读写\" class=\"headerlink\" title=\"读写\"></a>读写</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">string word;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(cin &gt;&gt; word) cout &lt;&lt; word &lt;&lt;endl;</span><br></pre></td></tr></table></figure>\n<p>使用getline()函数可以得到第一个参数的第一行(不带换行符)赋予第二个参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">string line;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">getline</span>(cin, line))</span><br><span class=\"line\">    cout&lt;&lt;line&lt;&lt;endl;</span><br></pre></td></tr></table></figure>\n<h3 id=\"关于字符串与字面值相加\"><a href=\"#关于字符串与字面值相加\" class=\"headerlink\" title=\"关于字符串与字面值相加\"></a>关于字符串与字面值相加</h3><p><mark>这是个坑</mark></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">&quot;hello &quot;</span> + <span class=\"string\">&quot;world&quot;</span>;<span class=\"comment\">//错误的</span></span><br><span class=\"line\">s = <span class=\"string\">&quot;hello &quot;</span>;s2 = s +<span class=\"string\">&quot;world&quot;</span>;<span class=\"comment\">//正确的</span></span><br></pre></td></tr></table></figure>\n<p>因为字面值字符串与c兼容并不是std::string 类型的, 他们是没有+这种操作的</p>\n<p>所以必须有一个string类型在里面</p>\n<h3 id=\"字符类型判断\"><a href=\"#字符类型判断\" class=\"headerlink\" title=\"字符类型判断\"></a>字符类型判断</h3><p>见c++ prime P82,3-2</p>\n<h3 id=\"c-11遍历操作\"><a href=\"#c-11遍历操作\" class=\"headerlink\" title=\"c++11遍历操作\"></a>c++11遍历操作</h3><ol>\n<li>只读</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">&quot;something&quot;</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c : s)&#123;</span><br><span class=\"line\">    cout &lt;&lt; c &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>改变原字符串 &amp;</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;c : s)&#123;<span class=\"comment\">//c为引用,原址操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c == <span class=\"string\">&quot;s&quot;</span>) c = <span class=\"string\">&quot;*&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cout &lt;&lt; s;</span><br></pre></td></tr></table></figure>\n<h1 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::vector;</span><br></pre></td></tr></table></figure>\n<h2 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector &lt;T&gt; v1;</span><br><span class=\"line\">vector &lt;T&gt; v1&#123;a,b,c&#125;;</span><br><span class=\"line\">vector &lt;T&gt; v1 = &#123;a,b,c&#125;;</span><br><span class=\"line\">vector &lt;T&gt; v2 = v1;</span><br><span class=\"line\">vector &lt;T&gt; <span class=\"built_in\">v2</span>(v1);</span><br><span class=\"line\">vector &lt;T&gt; <span class=\"built_in\">v3</span>(n, val);<span class=\"comment\">//n个重复val</span></span><br><span class=\"line\">vector &lt;T&gt; <span class=\"built_in\">v4</span>(n);<span class=\"comment\">//只是初始化n占位</span></span><br></pre></td></tr></table></figure>\n<p>注意()和{}, ()代表的是构造对象,里边是两个参数, {}是列表初始化,里边是实实在在的list</p>\n<h2 id=\"添加元素-push-back\"><a href=\"#添加元素-push-back\" class=\"headerlink\" title=\"添加元素 push_back\"></a>添加元素 push_back</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector &lt;T&gt; v;</span><br><span class=\"line\">v.<span class=\"built_in\">push_back</span>(value);</span><br></pre></td></tr></table></figure>\n<p>用法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i &lt;= n; ++i)&#123;</span><br><span class=\"line\">    v.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"type\">const</span> vector&lt;T&gt; &amp;vec)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c : vec) cout&lt;&lt;c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>for range型内不能进行push_back(),因为range不能在循环中发生改变</p>\n</li>\n<li><p>在<mark>添加或删除容器的内容后</mark>,所有的指针以及迭代器都失效了</p>\n</li>\n</ol>\n<p>注: for语句执行顺序-<mark>先判断再执行</mark></p>\n<p>初始赋值-&gt;初次判断-&gt;语句执行-&gt;表达式迭代-&gt;判断-&gt;执行-&gt;迭代…..</p>\n<p>也就是说,在写的时候只需要确定三个东西</p>\n<ol>\n<li><p>初始位置    [start, ….</p>\n</li>\n<li><p>迭代步长</p>\n</li>\n<li><p>终止位置    终止可以选择闭区间 <mark>&lt;= </mark>或是开区间 &lt;mark><</mark> </p>\n</li>\n<li><p>当使用的是&lt;=时,区间为[start, end]</p>\n<p> 当使用的是&lt;时,区间为[start, end)</p>\n</li>\n</ol>\n<p>推荐使用前闭后开,因为数组序号是0~n-1的,所以迭代[0, n)等价于[0,n-1]</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i) statement;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;=n<span class=\"number\">-1</span>; ++i) statement;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">v.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">v.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">v[n];<span class=\"comment\">//注意不能想超限的位置添加元素</span></span><br><span class=\"line\">v1 = v2;</span><br><span class=\"line\">v1 == v2;<span class=\"comment\">//!= &lt; &gt; &lt;= &gt;=</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"迭代器-iterator\"><a href=\"#迭代器-iterator\" class=\"headerlink\" title=\"迭代器 iterator\"></a>迭代器 iterator</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> begin = v.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"keyword\">auto</span> end = v.<span class=\"built_in\">end</span>();</span><br></pre></td></tr></table></figure>\n<p>begin指向第一个元素,end指向最后一个元素的<mark>下一个元素</mark></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">*iter;<span class=\"comment\">//解引用,注意得到的是原址对象</span></span><br><span class=\"line\">iter-&gt;mem;<span class=\"comment\">//等价于*(iter).mem</span></span><br><span class=\"line\">++iter;--iter;</span><br><span class=\"line\">iter == iter2;</span><br><span class=\"line\">iter += n;</span><br><span class=\"line\">iter +=iter2;</span><br></pre></td></tr></table></figure>\n<p><mark>判断vector非空</mark></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(v.<span class=\"built_in\">begin</span>() != v.<span class=\"built_in\">end</span>());</span><br></pre></td></tr></table></figure>\n<p>和指针类似, 迭代器分类型,也有const类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector &lt;<span class=\"type\">int</span>&gt;::iterator it;</span><br><span class=\"line\">vector &lt;<span class=\"type\">int</span>&gt;::const_iterator it;</span><br></pre></td></tr></table></figure>\n<p>类似的const_iterator只能读</p>\n<p>一下表达等价</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">*(it).<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">it-&gt;empty;</span><br></pre></td></tr></table></figure>\n<p>☆使用了迭代器后不要增删原容器内容,因为他们会重新分配内存</p>\n<h2 id=\"vector多维数组\"><a href=\"#vector多维数组\" class=\"headerlink\" title=\"vector多维数组\"></a>vector多维数组</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">array</span>(m); <span class=\"comment\">//m*m</span></span><br><span class=\"line\"><span class=\"comment\">//初始化一个m*n的二维数组</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++) &#123;</span><br><span class=\"line\">    array[i].<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">&#125;<span class=\"comment\">//本质上可以长短不一</span></span><br><span class=\"line\"><span class=\"comment\">//遍历赋值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; array.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; array[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();j++) &#123;</span><br><span class=\"line\">        array[i][j] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; &amp;vec)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> c : vec) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s : c )&#123;</span><br><span class=\"line\">            cout &lt;&lt; s &lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> </span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">//本质上变成这样也是一样的无非是显示方式</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>(m)内外都设置为m大小</li>\n<li>resize(n)</li>\n<li>array.size()行数—-array[0].size()列数</li>\n</ol>\n<p>所谓行列本质上没有意义,真正只有内外之分,无非是显示函数怎么写</p>\n<p>我们可以做出规定,为了写着方便认为—外层向下竖着排内层向横向展开</p>\n<p>这样既一个是行一个是列</p>\n<h1 id=\"显示类型转换\"><a href=\"#显示类型转换\" class=\"headerlink\" title=\"显示类型转换\"></a>显示类型转换</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">cast-<span class=\"built_in\">name</span>&lt;type&gt;(expression)</span><br></pre></td></tr></table></figure>\n<p>cast-name 有四种</p>\n<p>static_cast/dynamic_cast/const_cast/reinterpret_cast</p>\n<ul>\n<li><p>static_cast可以常用,但是不能改const</p>\n</li>\n<li><p>const_cast只能用作去const,不能改类型</p>\n</li>\n<li><p>其他两个暂不了解也不需要使用</p>\n</li>\n</ul>\n","categories":["日志"],"tags":["c++语法","string","vector"]},{"title":"Day1 学习总结","url":"/2022/02/25/Day1-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>摘要:①搞好了blog的一些显示问题,主要是使用了html标签的方式.</p>\n<p>​            ②找到了vis-M的专利.</p>\n<span id=\"more\"></span>\n<h4 id=\"上午10-00-11-45\"><a href=\"#上午10-00-11-45\" class=\"headerlink\" title=\"上午10:00-11.45\"></a>上午10:00-11.45</h4><ul>\n<li>[x] 搞好hexo的markdown渲染问题,熟悉一下Typora快捷键</li>\n<li>[x] 做一下下午的规划</li>\n</ul>\n<h2 id=\"hexo遗留问题\"><a href=\"#hexo遗留问题\" class=\"headerlink\" title=\"hexo遗留问题\"></a>hexo遗留问题</h2><p>三个额外的渲染需要用html标签实现了,高亮使用代码高亮或者<font color=\"#FF2222\">改变字体颜色</font>使用的是html语法</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">color</span>=<span class=\"string\">&quot;#十六进制色号&quot;</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><mark>mark标签高亮显示文本</mark></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mark</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">mark</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>cm<sup>3</sup>  H<sub>2</sub>O</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">sup</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">sup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">sub</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">sub</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>选中一整行是<mark>ctrl+L</mark></p>\n<p>选中单词是<mark>ctrl+D</mark></p>\n<p>hexo的文章摘要标记是:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure>\n<p>顺带一提把搜狗输入法的中文输入时的标点改为了英文</p>\n<p>网页背景更改:\\themes\\next\\source\\css_schemes\\Gemini\\index.styl下添加如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">body &#123; </span><br><span class=\"line\">\tbackground: url(/images/background.jpg);</span><br><span class=\"line\">\tbackground-repeat: no-repeat;// 设定背景图片非重复填充</span><br><span class=\"line\">\tbackground-attachment: fixed;// 设置背景图片不随页面滚动</span><br><span class=\"line\">\tbackground-position: 20% 20%;// 设置背景图片位置</span><br><span class=\"line\">\tbackground-size: cover//</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"下午规划\"><a href=\"#下午规划\" class=\"headerlink\" title=\"下午规划\"></a>下午规划</h3><ul>\n<li>[x] 把essential c++前三章好好看一下,对照之前写的码</li>\n<li>[x] 找一找光纤柔韧性(医学)相关的东西</li>\n<li>[ ] 找个c++的leetcode讲解不行在看左程云做一下刷题计划</li>\n</ul>\n<h2 id=\"柔性光纤文献思路\"><a href=\"#柔性光纤文献思路\" class=\"headerlink\" title=\"柔性光纤文献思路\"></a>柔性光纤文献思路</h2><p>flexible fiber bundle (FB)柔性光纤束</p>\n<p>这种东西是前向成像oct?但是似乎不需要旋转,他能不能用作iv成像.目前的两个关键参数:<mark>直径-柔韧性</mark>看一下参考文献fiber bundle/endoscopy</p>\n<p>居然连国内都有一家申请了专利,使用的是所谓弯曲不敏感型光纤(光纤直径为80um ~ 120um，光纤最小弯曲半径5 ~ 12mm)</p>\n<p>找到了vis-M的专利 <mark>☆</mark></p>\n<p><a href=\"https://patents.glgoo.top/\">谷歌专利查询</a>查询Gentuity—-imaging system with optical pathway</p>\n<p>明天详细看一看</p>\n<h2 id=\"c-复习-DAY1\"><a href=\"#c-复习-DAY1\" class=\"headerlink\" title=\"c++复习 DAY1\"></a>c++复习 DAY1</h2><h3 id=\"1-基本内置类型\"><a href=\"#1-基本内置类型\" class=\"headerlink\" title=\"1.基本内置类型\"></a>1.基本内置类型</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">位(字节)</th>\n<th>范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">bool</td>\n<td style=\"text-align:center\"></td>\n<td>true/false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">char</td>\n<td style=\"text-align:center\">1</td>\n<td>0~255</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">4</td>\n<td>-214783648~214783647</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">float</td>\n<td style=\"text-align:center\">4</td>\n<td>+/- 3.4e +/- 38 (~7 个数字)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">double</td>\n<td style=\"text-align:center\">8</td>\n<td>+/- 1.7e +/- 308 (~15 个数字)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>修饰符:</p>\n<p>signed/unsigned; short/long</p>\n<ul>\n<li><p>无符号类型变成从0开始</p>\n</li>\n<li><p>long修饰符占字符位×2; short修饰符占字符位÷2</p>\n</li>\n<li><p>一个字节占8个byte</p>\n</li>\n</ul>\n<p>注意无符号类型在循环条件中永远不会小于0的问题</p>\n<h3 id=\"2-变量初始化与作用域\"><a href=\"#2-变量初始化与作用域\" class=\"headerlink\" title=\"2.变量初始化与作用域\"></a>2.变量初始化与作用域</h3><p>Type name = value;  或Type name{value};</p>\n<p>extern关键字表示不初始化的声明变量</p>\n<p>在函数或代码块内部声明的为局部变量</p>\n<p>在函数外部声明的为全局变量</p>\n<p>在函数参数的定义中声明的为形式参数</p>\n<h3 id=\"3-复合类型-引用与指针\"><a href=\"#3-复合类型-引用与指针\" class=\"headerlink\" title=\"3.复合类型-引用与指针\"></a>3.复合类型-引用与指针</h3><p>这里的引用只介绍左值引用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ival = <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;ref_ival = ival;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;ref_ival2;<span class=\"comment\">//错误的,引用必须进行初始化</span></span><br></pre></td></tr></table></figure>\n<p>引用只是初始化对象的一个别名,它并不是一个真实存在的对象,因此也<mark>无法更改绑定对象</mark>; 无法定义引用的引用;  必须进行初始化(这三点是与指针的关键不同)</p>\n<p>对引用对象一切操作都是对原地址的操作</p>\n<hr>\n<p>​        指针(pointer)本质可以理解为一类数据类型, 在基本数据类型加 * 定义对应指针类型.</p>\n<p>允许对指针的赋值/拷贝/更改指向对象/无初始化(不要这么做)/定义指向其本身的指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* ptr = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"><span class=\"type\">double</span> dp, *dp2;<span class=\"comment\">//dp是double,dp2是指向double的指针类型</span></span><br><span class=\"line\"><span class=\"comment\">//最好不要这么写</span></span><br><span class=\"line\"><span class=\"type\">int</span> *p1, p2;<span class=\"comment\">//p1是指针而p2是int</span></span><br><span class=\"line\"><span class=\"comment\">//说实话写成int* p1要更好一些</span></span><br></pre></td></tr></table></figure>\n<p>取地址符 &amp; 取出变量的地址</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ival = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> *ptr = &amp;ival;</span><br></pre></td></tr></table></figure>\n<p>解引用符 *  得到指向的对象本身</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; *ptr; <span class=\"comment\">//输出1</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意取地址符与解引用符与数据类型定义时的引用与指针<mark>没有任何关系</mark></li>\n</ul>\n<p>指针的引用:(test)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ival = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>* ptr;</span><br><span class=\"line\"><span class=\"type\">int</span>* &amp;ref = ptr;</span><br><span class=\"line\">ref = &amp;ival;</span><br><span class=\"line\">*ref = <span class=\"number\">0</span>;</span><br><span class=\"line\">cout&lt;&lt;ival;<span class=\"comment\">//输出什么?</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-const与constexpr\"><a href=\"#4-const与constexpr\" class=\"headerlink\" title=\"4.const与constexpr\"></a>4.const与constexpr</h3><p>const修饰的变量不能改变内容</p>\n<p>可以将一个非const对象绑定到const修饰的引用上(反过来不行),这样就无法通过ref来修改(用来传参)</p>\n<p>当然const也能修饰指针,一个const类型的指针也必须用const修饰</p>\n<p>当然也可以用const指针指向一个非const变量,这样指针本身不能动但是可以修改其指向的对象</p>\n<p>常量表达式(const expression)</p>\n<p>当你确定后面的表达式/函数是一个const(不会改变)的时候就用constexpr修饰定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> mf = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> limit = mf+<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-typedef与auto\"><a href=\"#5-typedef与auto\" class=\"headerlink\" title=\"5.typedef与auto\"></a>5.typedef与auto</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> wage;</span><br><span class=\"line\">wage ival = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"type\">int</span> wage;<span class=\"comment\">//等价写法</span></span><br></pre></td></tr></table></figure>\n<p>auto修饰符会自己根据初始化判断数据类型</p>\n<h3 id=\"6-struct-建议直接class\"><a href=\"#6-struct-建议直接class\" class=\"headerlink\" title=\"6.struct//建议直接class\"></a>6.struct//建议直接class</h3><p>自定义数据类型</p>\n","categories":["日志"],"tags":["c++语法","markdown语法","柔性光纤"]},{"title":"day3-学习总结","url":"/2022/02/28/day3-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>矩阵分析,代码随想录2章</p>\n<p>递归算法的时间复杂度与空间复杂度</p>\n<p>递归算法的读法与写法</p>\n<span id=\"more\"></span>\n<h1 id=\"递归算法的写法\"><a href=\"#递归算法的写法\" class=\"headerlink\" title=\"递归算法的写法\"></a>递归算法的写法</h1><p>数学归纳法:</p>\n<p>1.确定递归变化量和每次的变化规则<strong>(函数参数和参数变化规则)</strong></p>\n<p>2.通过递归式得到a<sub>n-1</sub>的结果, 既我们假设除了最后一步计算都业已完成</p>\n<p>3.得到由a<sub>n-1</sub>到a<sub>n</sub>的计算步骤, 并返回结果</p>\n<p>4.因为数学归纳法,由a<sub>n-2</sub>到a<sub>n-1</sub>的计算是一样的所以递归式成立</p>\n<p>5.写出起始/终止 时的边界返回结果</p>\n<p>例: 反转链表</p>\n<p><img src=\"https://s2.loli.net/2022/02/28/XoFJ4zjYLiBsHuy.png\" alt=\"\"></p>\n<ol>\n<li><p>我们先<mark>假设n-1个链表已经反转完成了</mark></p>\n</li>\n<li><p>我们在遇到递归时,不要想这个里面是怎么递归的,直接把他认为一个黑箱已经帮我们得到了F(n-1)的结果</p>\n<p>本质上是把<mark>用现状态表示的下一个状态</mark>传给函数,循环往复</p>\n</li>\n<li><p>所以我们得到了除了1节点未完成的链表newhead, 如图</p>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode <span class=\"title\">F</span><span class=\"params\">(ListNode head)</span></span>&#123;</span><br><span class=\"line\">\tListNode newhead = <span class=\"built_in\">F</span>(head.next);</span><br><span class=\"line\">    <span class=\"comment\">//现在newhead指向5, head依旧指向1</span></span><br><span class=\"line\">    <span class=\"comment\">//head用完就要抛弃了</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s2.loli.net/2022/02/28/lWMDuk5LiYsKnhR.png\" alt=\"2\"></p>\n<ol>\n<li>然后对应的调整好指针</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode <span class=\"title\">F</span><span class=\"params\">(ListNode head)</span></span>&#123;</span><br><span class=\"line\">\tListNode newhead = <span class=\"built_in\">F</span>(head.next);</span><br><span class=\"line\">\thead.next.next = head.next;</span><br><span class=\"line\">\thead.next = null;</span><br><span class=\"line\">\tretrun newhead;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>边界条件</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(head == null || head.next == null) <span class=\"comment\">//也要防止本身链表就是空的</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> head;</span><br></pre></td></tr></table></figure>\n<h1 id=\"递归时间复杂度\"><a href=\"#递归时间复杂度\" class=\"headerlink\" title=\"递归时间复杂度\"></a>递归时间复杂度</h1><p>递归可以抽象成满二叉树,每个节点代表一次递归</p>\n<p>O(叶子节点数 * 每次的时间复杂度)</p>\n<p>满二叉树的叶子数为<mark>2<sup>m+1</sup>-1</mark>, m为深度m=<mark>log<sub>2</sub><sup>n</sup>-1</mark></p>\n","categories":["日志"]},{"title":"day4-学习总结","url":"/2022/03/01/day4-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>光纤进展-思路受阻没有确切的目标</p>\n<p>函数传参和返回值,与指针引用的结合</p>\n<p>螺旋阅读法</p>\n<span id=\"more\"></span>\n<h1 id=\"函数传形参\"><a href=\"#函数传形参\" class=\"headerlink\" title=\"函数传形参\"></a>函数传形参</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span> &amp;vec)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>复习一下引用的定义方式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> &amp;r = n;<span class=\"comment\">//r是n的别名</span></span><br></pre></td></tr></table></figure>\n<p>type &amp; 理解为引用类型</p>\n<p>const可以有效减少复杂数据结构的复制开销</p>\n<p>另外,如果不使用const引用,则普通的引用无法接受字面值,因为无法将const变量赋予一个非const引用</p>\n<h2 id=\"传递数组\"><a href=\"#传递数组\" class=\"headerlink\" title=\"传递数组\"></a>传递数组</h2><p>数组是不允许拷贝的,而且当我们传递时他会退化为指针</p>\n<p>int* 与int[]是完全不一致的</p>\n<p>所以我们传递数组时要想办法告诉函数他的范围</p>\n<p>传递数组的引用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> (&amp;arr)[<span class=\"number\">10</span>])</span></span>&#123;;&#125;<span class=\"comment\">//数组的引用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> &amp;arr[<span class=\"number\">10</span>])</span></span>&#123;;&#125;<span class=\"comment\">//包含10个引用的数组,并不存在这种东西</span></span><br></pre></td></tr></table></figure>\n<p>我们复习数组的定义规则: arr是名称声明,[]是修饰, <mark>*/&amp;的运算优先级是最低的</mark>所以</p>\n<h1 id=\"螺旋阅读法\"><a href=\"#螺旋阅读法\" class=\"headerlink\" title=\"螺旋阅读法\"></a>螺旋阅读法</h1><p>我们理解数组的声明分为三个部分,自身标识符,维度,内部数据类型</p>\n<p><code>int&amp; arr[10]</code>就可以直接看出&amp;不属于标识符而是内部数据类型</p>\n<p>由内而外的螺旋读法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *(&amp;arr)[<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n<p>首先,我们看未明确标识符arr,看到&amp;可以知道arr是一个引用</p>\n<p>然后右边,我们看到他是一个大小为10的数组的引用</p>\n<p>最后左边,我们知道数组的元素类型是int*</p>\n<p>所以这是一个含有10个int型指针的数组的引用</p>\n<p>我们复习一下指针和引用的声明:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>* ptr = &amp;i;<span class=\"comment\">//ptr是一个指向i的指针, &amp;在这里是取地址</span></span><br><span class=\"line\"><span class=\"type\">int</span> &amp;ref = *ptr;<span class=\"comment\">//这里的*表示解引用,不可和上面混淆,所以ref是i的引用</span></span><br><span class=\"line\"><span class=\"type\">int</span>* &amp;refptr = ptr;<span class=\"comment\">//refptr是ptr的引用</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"函数返回引用为左值\"><a href=\"#函数返回引用为左值\" class=\"headerlink\" title=\"函数返回引用为左值\"></a>函数返回引用为左值</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> &amp; <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> &amp;arr, <span class=\"type\">int</span> ix)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;arr[ix];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> main&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义略</span></span><br><span class=\"line\">    <span class=\"built_in\">func</span>(arr, ix) = <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>func返回了一个引用, 这个返回值是一个左值(<mark>其余类型返回量都为右值</mark>)</p>\n<p>我们可以对这个返回量直接进行修改</p>\n<p>在例子中,我们知道func接受了非const int数组,函数体中的arr仍然是原址的,又返回了arr一个位置的引用,那么对返回引用的修改,直接作用于了main中的arr.</p>\n<p>但是我们函数传参传过去非引用的话,这种行为是要绝对禁止的,因为复制后的地址会被销毁,会造成严重错误</p>\n<h1 id=\"尾置返回类型\"><a href=\"#尾置返回类型\" class=\"headerlink\" title=\"尾置返回类型\"></a>尾置返回类型</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> (*<span class=\"built_in\">func</span>(<span class=\"type\">int</span> i))[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> -&gt; <span class=\"title\">int</span> <span class=\"params\">(*)</span> [10]</span>&#123;&#125;;<span class=\"comment\">//等价</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">func</span><span class=\"params\">()</span> -&gt;<span class=\"type\">int</span></span>&#123;;&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h1><p>三个部分,原函数的返回值,(*func),参数类型列表.这些形状都一样的函数的指针也是一样的类型即使名字不同</p>\n<p>如 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> ptr = <span class=\"built_in\">int</span> (*func)(<span class=\"type\">int</span>, <span class=\"type\">int</span>*);</span><br></pre></td></tr></table></figure>\n<p>自然我们可以用传指针和返回指针</p>\n<p>推荐尾置写法写返回函数指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> (*<span class=\"built_in\">getfunc</span>(string))(<span class=\"type\">int</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">getfunc</span><span class=\"params\">(string)</span> -&gt; <span class=\"title\">int</span> <span class=\"params\">(*)</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span>;<span class=\"comment\">//等价</span></span><br></pre></td></tr></table></figure>\n<p>也可以使用decltype</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">decltype</span>(func) * <span class=\"built_in\">getfunc</span>(string)&#123;&#125;;<span class=\"comment\">//返回func函数指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(func) &amp; <span class=\"built_in\">getfunc</span>(string)&#123;&#125;;<span class=\"comment\">//返回func函数的引用</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(func) <span class=\"built_in\">getfunc</span>(string)&#123;&#125;;<span class=\"comment\">//返回func函数的类型</span></span><br></pre></td></tr></table></figure>\n","categories":["日志"]},{"title":"day5-学习总结","url":"/2022/03/02/day5-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>类的书写规则,构造函数,静态成员,this指针</p>\n<span id=\"more\"></span>\n<h1 id=\"类的书写规则\"><a href=\"#类的书写规则\" class=\"headerlink\" title=\"类的书写规则\"></a>类的书写规则</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> Stack&amp;)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">friend</span> returnType <span class=\"title\">somefunc</span><span class=\"params\">(Type)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//友元,做声明的外部函数可以访问private</span></span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack_friend</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">const</span> string&amp;)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> _stack.<span class=\"built_in\">size</span>();&#125;<span class=\"comment\">//内联函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">double</span> interrate;<span class=\"comment\">//非const静态成员,必须在外部初始化</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"keyword\">constexpr</span> <span class=\"type\">const</span> <span class=\"type\">double</span> const_interrate = <span class=\"number\">2</span>;<span class=\"comment\">//constexpr可以类内声明+初始化(c++11)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">double</span> <span class=\"title\">rate</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> interrate;&#125;<span class=\"comment\">//不传递this指针</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">rate</span><span class=\"params\">(<span class=\"type\">double</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Stack</span>(vector&lt;string&gt;);<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    vector&lt;string&gt; _stack = &#123;<span class=\"string\">&quot; &quot;</span>&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Stack::<span class=\"built_in\">Stack</span>(vector&lt;string&gt; _stack)&#123;</span><br><span class=\"line\">    _stack = &#123;<span class=\"string\">&quot;null&quot;</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//或者可以使用成员初始化列表</span></span><br><span class=\"line\">Stack::<span class=\"built_in\">Stack</span>(Stack &amp; rhs): _stack(rhs._stack)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Stack::push</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; elem)</span></span>&#123;</span><br><span class=\"line\">    _stack.<span class=\"built_in\">push_back</span>(elem);</span><br><span class=\"line\">    <span class=\"type\">double</span> rate = interrate;<span class=\"comment\">//直接访问静态成员</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> Stack&amp; v)</span></span>&#123;...&#125;<span class=\"comment\">//外部函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> Stack::interrate = <span class=\"number\">0.1</span>;<span class=\"comment\">//必须在外部声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Stack::rate</span><span class=\"params\">(<span class=\"type\">double</span> newrate)</span></span>&#123;</span><br><span class=\"line\">    interrate = newrate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//外部访问静态成员</span></span><br><span class=\"line\"><span class=\"type\">double</span> rate = Stack::rate;</span><br><span class=\"line\">Stack ac1;ac1-&gt;<span class=\"built_in\">rate</span>();</span><br></pre></td></tr></table></figure>\n<h1 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h1><p>this指针在成员函数中用作指向调用者(对象)本身, 在调用时隐式的传递给了成员函数</p>\n<p>this是一个const指针,不允许改变本身所储存的地址,当然地址指向的位置是否可以改变(底层const)由自身决定</p>\n<p>这样我们就不能将一个普通的this绑定到一个const对象上,这样const对象是不能调用非const函数的</p>\n<p>所以我们可以const修饰this指针</p>\n<h2 id=\"我们复习一下常量指针\"><a href=\"#我们复习一下常量指针\" class=\"headerlink\" title=\"我们复习一下常量指针:\"></a>我们复习一下常量指针:</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> ival = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> *ptr = &amp;ival;<span class=\"comment\">//ptr指向const int型,而地址本身是可变的</span></span><br><span class=\"line\"><span class=\"type\">int</span> *<span class=\"type\">const</span> ptr = &amp;ival;<span class=\"comment\">//错误的,ptr是一个指向非常量的常量指针</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> *<span class=\"type\">const</span> ptr = &amp;ival;<span class=\"comment\">//ptr存储地址本身不可变,也指向cosnt</span></span><br></pre></td></tr></table></figure>\n<p>我们称ptr本身不可变为顶层const,指向的类型为const为底层const,二者无任何关系</p>\n<p>回到this的问题上,this默认是顶层const的,要修饰为底层const以指向const对象:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;&#125;; </span><br></pre></td></tr></table></figure>\n<p>也可以称为常量成员函数</p>\n<h2 id=\"返回this\"><a href=\"#返回this\" class=\"headerlink\" title=\"返回this\"></a>返回this</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">className&amp; <span class=\"title\">className::func</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//返回引用类型,而且是一个左值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很明显一个const成员函数将会返回const型引用,因为const修饰了this,其底层也是const的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> className&amp; <span class=\"title\">className::func</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;<span class=\"comment\">//返回常量引用类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"构造函数-成员初始化列表\"><a href=\"#构造函数-成员初始化列表\" class=\"headerlink\" title=\"构造函数-成员初始化列表\"></a>构造函数-成员初始化列表</h1><p>如上文有两种初始化形式,两种是可以混用的</p>\n<p>此外类内直接进行初始化也是可行的,构造函数会进行覆盖</p>\n<ul>\n<li>成员初始化列表可以初始化一些对象</li>\n<li>类中的<mark>const成员变量,引用</mark>都要放在初始化列表之中进行</li>\n<li>列表是初始化,函数体内是赋值</li>\n</ul>\n<p>构造函数可以根据参数列表重构</p>\n<p>当我们主动写了带参数的构造函数后,最好写一个不带参的或者为每个参数都提供了默认值的默认构造函数</p>\n<p>因为我们当用到该类作为数据类型的容器时,必须调用默认构造函数如</p>\n<p><code>vector &lt;className&gt; vec(10)</code>如果className没有默认构造函数会报错</p>\n<h2 id=\"explicit\"><a href=\"#explicit\" class=\"headerlink\" title=\"explicit\"></a>explicit</h2><p><strong>隐式类型转换</strong> (<strong>构造函数的隐式调用</strong>)</p>\n<p>先来看一下这种隐式类型转换是怎么发生的</p>\n<p>当一个实参传给displayPoint时,编译器调用了构造函数,并且以实参为构造函数参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"built_in\">Point</span>(<span class=\"type\">int</span> x = <span class=\"number\">0</span>, <span class=\"type\">int</span> y = <span class=\"number\">0</span>)</span><br><span class=\"line\">        : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">displayPoint</span><span class=\"params\">(<span class=\"type\">const</span> Point&amp; p)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class=\"string\">&quot;,&quot;</span> </span><br><span class=\"line\">         &lt;&lt; p.y &lt;&lt; <span class=\"string\">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;<span class=\"comment\">//输出(1, 0)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">displayPoint</span>(<span class=\"number\">1</span>);<span class=\"comment\">//发生了隐式类型转换</span></span><br><span class=\"line\">    Point p = <span class=\"number\">1</span>;<span class=\"comment\">//</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们定义了一个再简单不过的<code>Point</code>类, 它的构造函数使用了默认参数. 这时主函数里的两句话都会触发该构造函数的隐式调用. (如果构造函数不使用默认参数, 会在编译时报错)</p>\n<p>显然, 函数<code>displayPoint</code>需要的是<code>Point</code>类型的参数, 而我们传入的是一个<code>int</code>, 这个程序却能成功运行, 就是因为这隐式调用. 另外说一句, 在对象刚刚定义时, 即使你使用的是赋值操作符<code>=</code>, 也是会调用构造函数, 而不是重载的<code>operator=</code>运算符.</p>\n<p>这样悄悄发生的事情, 有时可以带来便利, 而有时却会带来意想不到的后果. <code>explicit</code>关键字用来避免这样的情况发生.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"type\">int</span> x = <span class=\"number\">0</span>, <span class=\"type\">int</span> y = <span class=\"number\">0</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">        : x(x), y(y) &#123;</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">displayPoint</span><span class=\"params\">(<span class=\"type\">const</span> Point&amp; p)</span> </span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class=\"string\">&quot;,&quot;</span> </span><br><span class=\"line\">         &lt;&lt; p.y &lt;&lt; <span class=\"string\">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">displayPoint</span>(<span class=\"built_in\">Point</span>(<span class=\"number\">1</span>));<span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"function\">Point <span class=\"title\">p</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然即使这样我们仍然可以使用强制类型转换将1转为Point类类型</p>\n<p>c风格</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">Point(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>c++风格</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">static_cast</span>&lt;Point&gt; (<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>为了防止问题, 最后加<code>explicit</code>,当需要的时候进行显式的转换</p>\n<h1 id=\"mutable与const\"><a href=\"#mutable与const\" class=\"headerlink\" title=\"mutable与const\"></a>mutable与const</h1><p>用mutable修饰的数据成员,在任何时候(即使是const对象或是const函数中,都是可以改变它的)</p>\n<p>关于const可以修饰的类型:</p>\n<p>this指针(成员函数)/实例对象/类成员</p>\n<p>1）<strong>const成员函数</strong>可以访问<strong>非const对象的所有数据成员</strong>，也可以访问const对象内的所有数据成员；</p>\n<p>2）<strong>非const成员函数</strong>可以访问<strong>非const对象的所有数据成员</strong>，但<mark>不可以访问<em>const对象的任意数据成员</em></mark>；</p>\n<p><mark>反过来说, 非const对象可以访问任意成员函数,const对象只能访问const函数</mark></p>\n<p>3）同时出现时，非const对象优先调用非const成员函数。</p>\n<h1 id=\"基于const的二层重载\"><a href=\"#基于const的二层重载\" class=\"headerlink\" title=\"基于const的二层重载\"></a>基于const的二层重载</h1><p>我们经常需要一个const一个非const成员函数用于重载,但是显然我们不想写两遍</p>\n<p>那么两个函数同时引用一个private函数即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">screen</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">screen &amp; <span class=\"title\">display</span><span class=\"params\">(std::ostream &amp;os)</span></span></span><br><span class=\"line\"><span class=\"function\">    \t</span>&#123;<span class=\"built_in\">do_display</span>(os);<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> screen &amp; <span class=\"title\">display</span><span class=\"params\">(std::ostream &amp;os)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    \t</span>&#123;<span class=\"built_in\">do_display</span>(os);<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;&#125;    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">do_display</span><span class=\"params\">(std::ostream &amp;os)</span> <span class=\"type\">const</span> \t\t\t\t\t</span>&#123;os&lt;&lt;contents;&#125;<span class=\"comment\">//可以一次性修改实现</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样还可以解决另一个const问题:</p>\n<p>display()函数自然是不希望改变输入的,因此我们想到将其声明为const,但是同时我们希望他的返回*this不要是const的,这样普通的一层const是无法做到的</p>\n<p>因此我们嵌套了两层,第一层逻辑上只做调用第二层实现函数.第二层是const的</p>\n<p>我们观察:</p>\n<p>1) 当一个非const对象调用display时,将调用非常量的函数且返回一个非常量的引用;但是do_display将会<strong>接受this指针;然后将指针隐式转换为const</strong></p>\n<p>2) 当一个const对象调用display,只能调用常量函数且返回常量引用;do_display也将接受常量this指针<br>3) 最终,将会获得与对象类型一致的返回类型且实现内部都是const的;并且不需要多处复制修改</p>\n<h1 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h1><p>如果一个类中说明了静态数据成员，只有在这个类的第一个对象被创建时被初始化，自第二个对象起均不作初始化。</p>\n<p><strong>静态函数仅可以访问静态成员，或是静态成员函数或是静态数据成员。</strong>类的非静态成员函数却可以调用静态成员函数。</p>\n<p>静态数据成员可以在内部也可以在外部初始化,但是必须在类外部进行声明</p>\n<p>我们可以不依靠任何对象的使用静态成员函数/数据</p>\n","categories":["日志"]},{"title":"day6-学习总结","url":"/2022/03/03/day6-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>moc3</p>\n<span id=\"more\"></span>\n<h1 id=\"顺序容器库\"><a href=\"#顺序容器库\" class=\"headerlink\" title=\"顺序容器库\"></a>顺序容器库</h1><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">vector</td>\n<td>快速随机访问,尾部增删</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">list</td>\n<td>双向列表,双向顺序访问,中间位置增删</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">forward_list</td>\n<td>单向列表,单向顺序访问,中间位置增删</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">array</td>\n<td>固定大小数组不能增删</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">string</td>\n<td>与vector类似,储存字符专用</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">deque</td>\n<td>双端队列,快速随机访问,头尾增删</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h1 id=\"hexo-moc3\"><a href=\"#hexo-moc3\" class=\"headerlink\" title=\"hexo moc3\"></a>hexo moc3</h1><p>在next layout layout.swig中增加</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">      <span class=\"comment\">&lt;!-- Canvas --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;Canvas&quot;</span>  <span class=\"attr\">id</span>=<span class=\"string\">&quot;L2dCanvas&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">var</span> config = &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"attr\">width</span>: <span class=\"number\">700</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"attr\">height</span>: <span class=\"number\">700</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"attr\">left</span>: <span class=\"string\">&#x27;-90px&#x27;</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"attr\">bottom</span>: <span class=\"string\">&#x27;-140px&#x27;</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"attr\">basePath</span>: <span class=\"string\">&#x27;https://cdn.jsdelivr.net/gh/alg-wiki/AzurLaneL2DViewer@gh-pages/assets&#x27;</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"attr\">role</span>: <span class=\"string\">&#x27;nengdai_2&#x27;</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"attr\">background</span>: <span class=\"literal\">null</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"attr\">opacity</span>: <span class=\"number\">1</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"attr\">mobile</span>: <span class=\"literal\">true</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">var</span> v = <span class=\"keyword\">new</span> <span class=\"title class_\">Viewer</span>(config); </span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n","categories":["日志"]},{"title":"day7-学习总结","url":"/2022/03/04/day7-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>顺序容器</p>\n<span id=\"more\"></span>\n<h1 id=\"容器迭代器\"><a href=\"#容器迭代器\" class=\"headerlink\" title=\"容器迭代器\"></a>容器迭代器</h1><p>迭代器范围[begin, end)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(begin != end)&#123;</span><br><span class=\"line\">\t*begin = val;</span><br><span class=\"line\">    ++begin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">list&lt;string&gt;::iterator iter  = a.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">list&lt;string&gt;::cosnt_iterator iter2  = a.<span class=\"built_in\">cbegin</span>();</span><br><span class=\"line\"><span class=\"keyword\">auto</span> iter3  = a.<span class=\"built_in\">cbegin</span>();<span class=\"comment\">//auto最好的应用之一就是迭代器</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"stl-array\"><a href=\"#stl-array\" class=\"headerlink\" title=\"stl array\"></a>stl array</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">array&lt;type, size&gt;;</span><br><span class=\"line\">array&lt;<span class=\"type\">int</span>, 10&gt; arr1 = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;;</span><br><span class=\"line\">array&lt;<span class=\"type\">int</span>, 10&gt; arr2 = &#123;<span class=\"number\">0</span>&#125;<span class=\"comment\">//剩余的为0</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"与assign与swap\"><a href=\"#与assign与swap\" class=\"headerlink\" title=\"=与assign与swap\"></a>=与assign与swap</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">arr1 = arr2;<span class=\"comment\">//替换为右侧容器</span></span><br><span class=\"line\">vec1 = &#123;a,b,c&#125;;<span class=\"comment\">//其他容器可以赋予花括号列表</span></span><br><span class=\"line\">arr1 = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>&#125;<span class=\"comment\">//错误的</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//assign不适用关联容器和array</span></span><br><span class=\"line\">seq.<span class=\"built_in\">assign</span>(iter1, iter2);<span class=\"comment\">//iter1/2是另一个容器的迭代器,将范围内的元素替换掉seq原有元素</span></span><br><span class=\"line\">seq.<span class=\"built_in\">assign</span>(il);<span class=\"comment\">//替换为初始化列表il</span></span><br><span class=\"line\">seq.<span class=\"built_in\">assign</span>(n,value);<span class=\"comment\">//替换为n个value</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"swap\"><a href=\"#swap\" class=\"headerlink\" title=\"swap\"></a>swap</h2><p>swap不会导致指向容器的指针/容器/迭代器失效(array和string除外)</p>\n<p>例如本来指向<code>vec1[2]</code>, swap后会指向<code>vec2[2]</code></p>\n<p><code>swap(vec1, vec2);</code></p>\n<h1 id=\"大小比较操作\"><a href=\"#大小比较操作\" class=\"headerlink\" title=\"大小比较操作\"></a>大小比较操作</h1><p>都支持比较操作符,只能比相同容器相同类型</p>\n<ul>\n<li>相同size且两两对应相等才相等</li>\n<li>size不同,但是每个对应元素都相等, size大的更大</li>\n<li>两个不同size的比较,取决于<mark>第一个不同的元素的比较</mark></li>\n</ul>\n<p>这种比较是基于元素类型本身的运算符的, 如果类型不支持这些也就无法进行</p>\n<p>因此对自己的类定义比较运算符有很大的意义</p>\n<h1 id=\"顺序容器插入元素\"><a href=\"#顺序容器插入元素\" class=\"headerlink\" title=\"顺序容器插入元素\"></a>顺序容器插入元素</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">push_back</span>(val);</span><br><span class=\"line\"><span class=\"built_in\">push_front</span>(val);<span class=\"comment\">//仅list/forward_list/deque支持</span></span><br><span class=\"line\"><span class=\"built_in\">insert</span>(iter, value);</span><br><span class=\"line\"><span class=\"comment\">//插入iter之前,返回指向新元素的迭代器</span></span><br><span class=\"line\"><span class=\"comment\">//vector/ deque/list/ string. 注意forward不使用insert函数</span></span><br><span class=\"line\"><span class=\"built_in\">insert</span>(iter, num, value);<span class=\"comment\">//iter前插入10个value</span></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; v = &#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">slist.<span class=\"built_in\">insert</span>(slist.iter, v.<span class=\"built_in\">end</span>()<span class=\"number\">-1</span>, v.<span class=\"built_in\">end</span>());<span class=\"comment\">//输入另一个容器的迭代器</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"访问元素\"><a href=\"#访问元素\" class=\"headerlink\" title=\"访问元素\"></a>访问元素</h1><p><mark>首先必须检查是否含有元素<code>.empty()</code></mark></p>\n<ul>\n<li><code>c.back()</code>返回c的尾元素引用, forward_list不支持</li>\n<li><code>c.front</code>返回c的首元素引用</li>\n<li><code>c[n]</code>,<code>c.at(n)</code>适用于string/vector/deque/array </li>\n<li><code>.at(n)</code>可以在越界时报错</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!c.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">    c.<span class=\"built_in\">front</span>() = <span class=\"number\">42</span>;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> &amp;v = c.<span class=\"built_in\">back</span>();</span><br><span class=\"line\">    v = <span class=\"number\">1024</span>;<span class=\"comment\">//改变c</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> val = c.<span class=\"built_in\">back</span>();<span class=\"comment\">//val是一个拷贝而非引用</span></span><br><span class=\"line\">    val = <span class=\"number\">10</span>;<span class=\"comment\">//不改变c</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">vec</span><span class=\"params\">(<span class=\"number\">5</span>,<span class=\"number\">33</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"keyword\">auto</span> &amp;v = vec.<span class=\"built_in\">back</span>();<span class=\"comment\">//返回const引用</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> &amp;v = vec.<span class=\"built_in\">back</span>();<span class=\"comment\">//返回非const引用</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"关于auto与const-amp\"><a href=\"#关于auto与const-amp\" class=\"headerlink\" title=\"关于auto与const/&amp;\"></a>关于auto与const/&amp;</h2><p>如上面所见, 只使用auto时会去除<mark>引用/&amp;</mark>和<mark>const</mark>语义</p>\n<p>需要显式的把&amp;和const加上才行</p>\n<ul>\n<li>而加上&amp;后会保留const语义, 但是加const不会保留&amp;</li>\n</ul>\n<h1 id=\"删除元素\"><a href=\"#删除元素\" class=\"headerlink\" title=\"删除元素\"></a>删除元素</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//全部适用于array</span></span><br><span class=\"line\"><span class=\"comment\">//forward不支持pop_back()和erase();</span></span><br><span class=\"line\"><span class=\"comment\">//vector和stirng不支持pop_front()</span></span><br><span class=\"line\"><span class=\"built_in\">pop_back</span>();<span class=\"comment\">//返回void</span></span><br><span class=\"line\"><span class=\"built_in\">pop_front</span>();<span class=\"comment\">//返回void</span></span><br><span class=\"line\">c.<span class=\"built_in\">erase</span>(p);<span class=\"comment\">//迭代器.返回指向被删元素后元素的迭代器</span></span><br><span class=\"line\">c.<span class=\"built_in\">erase</span>(b,e);<span class=\"comment\">//迭代器位置</span></span><br><span class=\"line\">c.<span class=\"built_in\">clear</span>();</span><br></pre></td></tr></table></figure>\n<h1 id=\"改变容器大小-resize\"><a href=\"#改变容器大小-resize\" class=\"headerlink\" title=\"改变容器大小-resize\"></a>改变容器大小-resize</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">list&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">ilist</span><span class=\"params\">(<span class=\"number\">10</span>,<span class=\"number\">42</span>)</span></span>;</span><br><span class=\"line\">ilist.<span class=\"built_in\">resize</span>(<span class=\"number\">15</span>);<span class=\"comment\">//将5个0添加到末尾</span></span><br><span class=\"line\">ilist.<span class=\"built_in\">resize</span>(<span class=\"number\">15</span>,<span class=\"number\">-1</span>);<span class=\"comment\">//将5个-1添加到末尾</span></span><br><span class=\"line\">ilist.<span class=\"built_in\">resize</span>(<span class=\"number\">5</span>);<span class=\"comment\">//末尾删除10个元素</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"forward-list\"><a href=\"#forward-list\" class=\"headerlink\" title=\"forward_list\"></a>forward_list</h2><p>用到在看,先跳过</p>\n<h1 id=\"迭代器失效问题\"><a href=\"#迭代器失效问题\" class=\"headerlink\" title=\"迭代器失效问题\"></a>迭代器失效问题</h1><p>添加或删除元素时, vector/string/deque的迭代器会发生失效</p>\n<p>对于list和forward_list只会导致增删位置失效</p>\n<p>虽然deque会有些许不同,最好能必须保证每次循环步中重新更新迭代器</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt; Vec;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> vector&lt;<span class=\"type\">int</span>&gt;::iterator VecIt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteValueFromVector</span><span class=\"params\">(Vec &amp;v, <span class=\"type\">int</span> n = <span class=\"number\">5</span>)</span></span>&#123;</span><br><span class=\"line\">\tVecIt it;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(it = v.<span class=\"built_in\">begin</span>(); it != v.<span class=\"built_in\">end</span>(); it++)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"number\">0</span> == *it % n)&#123;</span><br><span class=\"line\">\t\t\tv.<span class=\"built_in\">erase</span>(it);<span class=\"comment\">//出现错误</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在删除it指向后,迭代器失效,重新分配内存, it已经失效</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteValueFromVector</span><span class=\"params\">(Vec &amp;v, <span class=\"type\">int</span> n = <span class=\"number\">5</span>)</span></span>&#123;</span><br><span class=\"line\">\tVecIt it;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(it = v.<span class=\"built_in\">begin</span>(); it != v.<span class=\"built_in\">end</span>(); )&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(<span class=\"number\">0</span> == *it % n)&#123;</span><br><span class=\"line\">\t\t\tit = v.<span class=\"built_in\">erase</span>(it);<span class=\"comment\">//更新,erase返回删除后下一个迭代器</span></span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            it++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>insert()返回新添加元素的迭代器,注意是插入到iter前,所以本质上前移了一位,如果it++可能导致永远在初始iter</li>\n<li>也就是说在有增删操作后, 注意有迭代器参与的条件语句</li>\n<li>迭代器尽量随用随取, 不要跨太远后再用</li>\n</ul>\n<h1 id=\"容器适配器\"><a href=\"#容器适配器\" class=\"headerlink\" title=\"容器适配器\"></a>容器适配器</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">stack&lt;string, vector&lt;string&gt;&gt; <span class=\"built_in\">str_string</span>(svec);</span><br><span class=\"line\">str_string.<span class=\"built_in\">push</span>(item);<span class=\"comment\">//压栈</span></span><br><span class=\"line\">str_string.<span class=\"built_in\">pop</span>();<span class=\"comment\">//删除栈顶</span></span><br><span class=\"line\">str_string.<span class=\"built_in\">top</span>();<span class=\"comment\">//返回栈顶元素</span></span><br></pre></td></tr></table></figure>\n","categories":["日志"]},{"title":"day8-学习总结","url":"/2022/03/08/day8-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>谓词与lambda</p>\n<span id=\"more\"></span>\n<h1 id=\"向函数传递谓词-predicate\"><a href=\"#向函数传递谓词-predicate\" class=\"headerlink\" title=\"向函数传递谓词(predicate)\"></a>向函数传递谓词(predicate)</h1><p>向标准库泛型算法可以添加一个谓词</p>\n<p>标准库函数使用两种,分别是一元谓词和二元谓词</p>\n<p>一般的sort使用<code>&lt;</code>来比较元素, 我们使用一个比较字符长度的函数来代替</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isshorter</span><span class=\"params\">(<span class=\"type\">const</span> string &amp;s1, <span class=\"type\">const</span> string &amp;s2)</span></span>&#123;</span><br><span class=\"line\">    retrun s1.<span class=\"built_in\">size</span>() &lt; s2.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">sort</span>(words.<span class=\"built_in\">begin</span>(), words.<span class=\"built_in\">end</span>(), isshorter);</span><br></pre></td></tr></table></figure>\n<h1 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a>lambda表达式</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">[capture list] (parameter list) -&gt; <span class=\"keyword\">return</span> type &#123;function body&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> f = [] &#123;<span class=\"keyword\">return</span> <span class=\"number\">42</span>;&#125;<span class=\"comment\">//参数列表和返回类型可以省略</span></span><br><span class=\"line\"><span class=\"comment\">//只有一条return时自动推断,否则返回void</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> func = [](<span class=\"type\">const</span> string &amp;s1, <span class=\"type\">const</span> string &amp;s2)&#123;retrun s1.<span class=\"built_in\">size</span>() &lt; s2.<span class=\"built_in\">size</span>();&#125;</span><br><span class=\"line\"><span class=\"built_in\">sort</span>(words.<span class=\"built_in\">begin</span>(), words.<span class=\"built_in\">end</span>(), func);</span><br></pre></td></tr></table></figure>\n<h2 id=\"捕获列表\"><a href=\"#捕获列表\" class=\"headerlink\" title=\"捕获列表\"></a>捕获列表</h2><p><code>[]</code>可以捕获lambda所在函数的局部变量</p>\n<p>可以捕获引用, 也支持隐式捕获写成<code>[&amp;]</code>(全为引用形式)<code>[=]</code>全为值引用</p>\n<p>或是混合使用隐式捕获或显示捕获<code>[=, &amp;os, c]</code></p>\n<p>捕获列表可以解决需要多个参数, 但一员谓词只接受一个参数的情况</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">biggies</span><span class=\"params\">(vector&lt;string&gt; &amp;words, \t\t\t\t\t\t\tvector&lt;string&gt;::size_type sz)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">elimDups</span>(words);</span><br><span class=\"line\">    <span class=\"built_in\">stable_sort</span>(words.begins, words.<span class=\"built_in\">end</span>(), isshorter);</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> wc = <span class=\"built_in\">find_if</span>(words.begins, words.<span class=\"built_in\">end</span>(),[sz](<span class=\"type\">const</span> strinf &amp;a)&#123;<span class=\"keyword\">return</span> a.size &gt;= sz;&#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>find_if只接受一元谓词,返回第一个使谓词返回非0值的元素,如不存在返回尾迭代器</p>\n","categories":["日志"]},{"title":"Hello World","url":"/2022/02/24/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"day9-学习总结","url":"/2022/03/09/day9-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>关联容器</p>\n<span id=\"more\"></span>\n<h1 id=\"标准库bind函数\"><a href=\"#标准库bind函数\" class=\"headerlink\" title=\"标准库bind函数\"></a>标准库bind函数</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> newCallable = <span class=\"built_in\">bind</span>(callable, argList);</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std::placeholders;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> check = <span class=\"built_in\">bind</span>(check_size, _1, sz);<span class=\"comment\">//_1是占位符</span></span><br><span class=\"line\"><span class=\"comment\">//表示sz是第二个参数, _2/_3以此类推</span></span><br></pre></td></tr></table></figure>\n<p>bind生成一个可调用对象, 将check_size第二个参数绑定到sz的值,  在泛型算法调用find_if的时候, 将string和sz传递给它. 注意参数是被拷贝到返回的新可调用对象的.</p>\n<p>有些类型是不能拷贝的,比如istream</p>\n<p>我们可以使用ref()或cref()包裹参数, 让其以引用或常量引用的形式绑定</p>\n<p>使用bind函数调换参数顺序</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span>(words.<span class=\"built_in\">begin</span>(), words.<span class=\"built_in\">end</span>(), isshorter);</span><br><span class=\"line\"><span class=\"built_in\">sort</span>(words.<span class=\"built_in\">begin</span>(), words.<span class=\"built_in\">end</span>(), <span class=\"built_in\">bind</span>(isshorter, _2, _1));</span><br><span class=\"line\"><span class=\"comment\">//调换了words输入的顺序,变为了isshorter(B,A)</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"map和set\"><a href=\"#map和set\" class=\"headerlink\" title=\"map和set\"></a>map和set</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">map&lt;string, <span class=\"type\">size_t</span>&gt; word_count;</span><br><span class=\"line\">set&lt;string&gt; exclude = &#123;<span class=\"string\">&quot;the&quot;</span>, <span class=\"string\">&quot;of&quot;</span>, <span class=\"string\">&quot;but&quot;</span>, <span class=\"string\">&quot;and&quot;</span>&#125;;</span><br><span class=\"line\">map&lt;string, string&gt; authors = &#123; &#123;<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;A&quot;</span>&#125;,</span><br><span class=\"line\">                                &#123;<span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;B&quot;</span>&#125;,</span><br><span class=\"line\">                                &#123;<span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;C&quot;</span>&#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">//map/set要求关键字(key)是唯一的.</span></span><br><span class=\"line\"><span class=\"comment\">//multimap和multiset不是</span></span><br></pre></td></tr></table></figure>\n<p>map/set/multimap/multiset为有序关联容器</p>\n<p>有序容器的关键字类型必须定义有元素比较的方法, 必须定义一个严格弱序的<code>&lt;</code></p>\n<p>如我们定义一个sale_data类类型的multiset, 我们需要定义一个sale_data类类型的严格弱序</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">compareISBN</span><span class=\"params\">(<span class=\"type\">const</span> sale_data &amp;lhs, <span class=\"type\">const</span> sale_data &amp; rhs)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lhs.<span class=\"built_in\">isbn</span>() &lt; lhs.<span class=\"built_in\">isbn</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后将比较操作函数的指针传递给multiset,且用函数初始化对象</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">multiset&lt;sale_data, <span class=\"title\">decltype</span><span class=\"params\">(compareISBN)</span> *&gt; </span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">bookstore</span><span class=\"params\">(compareISBN)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>当然也可以使用无序容器</p>\n<h1 id=\"pair\"><a href=\"#pair\" class=\"headerlink\" title=\"pair\"></a>pair</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">pair&lt;T1, T2&gt; <span class=\"title\">p</span><span class=\"params\">(v1, v2)</span></span>;<span class=\"comment\">//使用v1,v2初始化</span></span><br><span class=\"line\">pair&lt;T1, T2&gt; p = &#123;v1,v2&#125;;</span><br><span class=\"line\"><span class=\"built_in\">make_pair</span>(v1, v2);<span class=\"comment\">//从v1,v2默认推导来初始化pair</span></span><br><span class=\"line\"></span><br><span class=\"line\">pair.first; <span class=\"comment\">//返回公有数据成员</span></span><br><span class=\"line\">pair.second;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"关联容器操作\"><a href=\"#关联容器操作\" class=\"headerlink\" title=\"关联容器操作\"></a>关联容器操作</h1><p>域作用符提取成员type</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">map&lt;T1, T2&gt;::key_type;</span><br><span class=\"line\">map&lt;T1, T2&gt;::mapped_type;</span><br><span class=\"line\">set&lt;T&gt;::key_type;</span><br></pre></td></tr></table></figure>\n<p>map的迭代器指向一个pair</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> map_it = wordcount.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">map_it-&gt;first;map_it-&gt;second;</span><br><span class=\"line\"><span class=\"comment\">//可以改变元素但是不能改变关键字</span></span><br><span class=\"line\">++map_it-&gt;first;<span class=\"comment\">//错误的</span></span><br><span class=\"line\">++map_it-&gt;second;</span><br></pre></td></tr></table></figure>\n<p>set的迭代器不允许改变</p>\n<h2 id=\"添加-删除元素\"><a href=\"#添加-删除元素\" class=\"headerlink\" title=\"添加/删除元素\"></a>添加/删除元素</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">c.<span class=\"built_in\">insert</span>(v);</span><br><span class=\"line\">c.<span class=\"built_in\">emplace</span>(args);</span><br><span class=\"line\">c.<span class=\"built_in\">insert</span>(b,e);</span><br><span class=\"line\">c.<span class=\"built_in\">insert</span>(list);</span><br><span class=\"line\"></span><br><span class=\"line\">c.<span class=\"built_in\">erase</span>(key_value);</span><br><span class=\"line\">c.<span class=\"built_in\">erase</span>(iter);</span><br><span class=\"line\">c.<span class=\"built_in\">erase</span>(b,e);</span><br></pre></td></tr></table></figure>\n<h2 id=\"下标操作\"><a href=\"#下标操作\" class=\"headerlink\" title=\"下标操作\"></a>下标操作</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">map_name[key_value] = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>如果不存在这个key,则新建一个,可以这样给空map增加值</p>\n<ul>\n<li>如果不希望新增请使用find()</li>\n</ul>\n<p>显然下标操作会得到一个左值</p>\n<p><code>map_name.at(key)</code>则会在没有这个key时报错</p>\n<h2 id=\"访问元素\"><a href=\"#访问元素\" class=\"headerlink\" title=\"访问元素\"></a>访问元素</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">c.<span class=\"built_in\">find</span>(k);<span class=\"comment\">//返回迭代器,指向第一个key为k的元素</span></span><br><span class=\"line\">c.<span class=\"built_in\">count</span>(k);<span class=\"comment\">//返回k的数量</span></span><br><span class=\"line\">c.<span class=\"built_in\">lower_bound</span>(k);<span class=\"comment\">//返回指向第一个关键字不小于k的元素</span></span><br><span class=\"line\">c.<span class=\"built_in\">upper_bound</span>(k);<span class=\"comment\">//返回指向第一个关键字大于k的元素</span></span><br><span class=\"line\">c.<span class=\"built_in\">equal_range</span>(k);<span class=\"comment\">//返回迭代器pair, 等于k的元素的范围 </span></span><br></pre></td></tr></table></figure>\n<p>如果是multiset, 相同key的会相邻储存,所以想find到所有符合的元素</p>\n<p>有两种方法</p>\n<ul>\n<li>使用<code>count()</code>和<code>find()</code>逐一迭代</li>\n<li>使用<code>lower_bound()</code>和<code>upper_bound()</code></li>\n<li>直接使用<code>equal_range()</code></li>\n</ul>\n<h1 id=\"无序容器\"><a href=\"#无序容器\" class=\"headerlink\" title=\"无序容器\"></a>无序容器</h1><p>unorder_map/unorder_set/unorder_multimap/unorder_multiset</p>\n<p>无序容器各种操作都与有序一致, 对于底层hash和桶的操作暂且不表</p>\n","categories":["日志"]},{"title":"markdown","url":"/2022/02/24/markdown/","content":"<h1 id=\"markdown\"><a href=\"#markdown\" class=\"headerlink\" title=\"markdown\"></a>markdown</h1><p><strong>加粗</strong></p>\n<p><em>倾斜</em></p>\n<p><u>下划线</u></p>\n<p>==高亮==</p>\n<p>cm^3^</p>\n<p>H~2~O</p>\n<span id=\"more\"></span>\n<h2 id=\"列表：\"><a href=\"#列表：\" class=\"headerlink\" title=\"列表：-\"></a>列表：-</h2><ul>\n<li>1<ul>\n<li>1.1<ul>\n<li>1.1.1<ul>\n<li>1.1.1.1</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2</li>\n</ul>\n<p>有序列表：1.</p>\n<ol>\n<li>第一<ol>\n<li>不能二级</li>\n</ol>\n</li>\n<li>第二</li>\n<li>第三</li>\n</ol>\n<p>待办事项：</p>\n<ul>\n<li>[ ] 干活</li>\n</ul>\n<h2 id=\"行内代码：int整形\"><a href=\"#行内代码：int整形\" class=\"headerlink\" title=\"行内代码：int整形\"></a>行内代码：<code>int</code>整形</h2><p>代码块：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> main</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">我</th>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:right\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\">你</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">地方</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p>我没说过-鲁迅<sup><a href=\"#fn_1\" id=\"reffn_1\">1</a></sup></p>\n</blockquote>\n<p>哔站是<a href=\"https://www.bilibili.com\">bilibili</a></p>\n<p>跳转<a href=\"#markdown\">一级标题</a>小括号内是#加完全一致的内容</p>\n<h2 id=\"插入图片picgo\"><a href=\"#插入图片picgo\" class=\"headerlink\" title=\"插入图片picgo\"></a>插入图片picgo</h2><p><img src=\"https://s2.loli.net/2022/02/24/qPZwiMHbBstfojU.png\" style=\"zoom:33%;\" /></p>\n<blockquote id=\"fn_1\">\n<sup>1</sup>. 我自己说的<a href=\"#reffn_1\" title=\"Jump back to footnote [1] in the text.\"> &#8617;</a>\n</blockquote>\n<p>分割线</p>\n<hr>\n","categories":["Hexo"],"tags":["markdown","学习"]},{"title":"day10-学习总结","url":"/2022/03/10/day10-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>智能指针</p>\n<span id=\"more\"></span>\n<h1 id=\"share-ptr\"><a href=\"#share-ptr\" class=\"headerlink\" title=\"share_ptr\"></a>share_ptr</h1><p>有两种智能指针—share_ptr和unique_ptr还有一种伴随类weak_ptr指向share_ptr所管理的对象.</p>\n<p>首先我们看share_ptr</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">share_ptr&lt;Type&gt; sp;<span class=\"comment\">//声明空指针</span></span><br><span class=\"line\">unique_ptr&lt;Type&gt; up;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//以下操作二者共有</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(sp)&#123;;&#125;<span class=\"comment\">//用sp是否为空判断</span></span><br><span class=\"line\">*sp;</span><br><span class=\"line\">sp-&gt;member;<span class=\"comment\">//(*sp).member</span></span><br><span class=\"line\">sp.<span class=\"built_in\">get</span>();<span class=\"comment\">//取得其中的裸指针,小心</span></span><br><span class=\"line\"><span class=\"built_in\">swap</span>(sp1, sp2);<span class=\"comment\">//交换</span></span><br><span class=\"line\">sp1.<span class=\"built_in\">swap</span>(sp2);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//share_ptr独有操作</span></span><br><span class=\"line\"><span class=\"built_in\">make_share</span>&lt;Type&gt;(args);<span class=\"comment\">//返回share_ptr指向一个类型为Type的对象,用args初始化</span></span><br><span class=\"line\">share_ptr&lt;Type&gt;<span class=\"built_in\">sp2</span>(sp);<span class=\"comment\">//sp2是sp的拷贝,递增sp的计数器,sp的类型需要可以转换为T*类型</span></span><br><span class=\"line\">sp = sp2;<span class=\"comment\">//会引发sp计数器--;sp2++</span></span><br><span class=\"line\">sp.<span class=\"built_in\">unique</span>();<span class=\"comment\">//sp计数器为1时返回true;否则false</span></span><br><span class=\"line\">sp.<span class=\"built_in\">use_count</span>();<span class=\"comment\">//返回与sp共享对象的智能指针数量,用于调试</span></span><br></pre></td></tr></table></figure>\n<p>share_ptr最核心的理念是每个share_ptr都有一个关联的计数器, 也就是内部有一个指针指向包括计数器的控制块, 而拷贝这个share_ptr时这个指针也会被拷贝,既指向同一个控制块</p>\n<ul>\n<li>记录有多少个其他share_ptr指向同一对象</li>\n<li>拷贝发生时(用一个去初始化另一个, 函数传参, 函数返回值)计数器++</li>\n<li>给share_ptr赋予新值, 或被销毁(离开作用域)计数器—</li>\n<li>计数器为0自动释放管理的对象</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2022/03/10/GRXzW1oveYfSamr.jpg\" alt=\"img\"></p>\n<h1 id=\"unique-ptr\"><a href=\"#unique-ptr\" class=\"headerlink\" title=\"unique_ptr\"></a>unique_ptr</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">unique_ptr&lt;T&gt; u1;</span><br><span class=\"line\">unique_ptr&lt;T, D&gt; u1;<span class=\"comment\">//使用类型为D的可调用对象释放指针</span></span><br><span class=\"line\"><span class=\"function\">unique_ptr&lt;T, D&gt; <span class=\"title\">u1</span><span class=\"params\">(d)</span></span>;<span class=\"comment\">//使用类型为D的对象d代替delete</span></span><br><span class=\"line\">u = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">u.<span class=\"built_in\">release</span>();<span class=\"comment\">//放弃控制权,返回指针,将u置为空</span></span><br><span class=\"line\">u.<span class=\"built_in\">reset</span>(q);<span class=\"comment\">//释放u指向的对象,另u指向内置指针q指向的对象</span></span><br></pre></td></tr></table></figure>\n<p>同一时刻只能有一个unique_ptr指向一个给定对象,销毁unique_ptr就会同时销毁对象</p>\n<p>unique不支持拷贝和赋值,只能使用<code>reset(q)</code></p>\n<p>传入删除器, 可以传入函数或lambda表达式</p>\n","categories":["日志"]},{"title":"c++临时对象的析构问题","url":"/2022/03/10/c-%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%90%E6%9E%84%E9%97%AE%E9%A2%98/","content":"<p>什么是临时对象, 它的析构是怎么回事, 以及所带来的坑及回避</p>\n<span id=\"more\"></span>\n<p>首先我们看一段程序</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">char</span>* c = <span class=\"built_in\">string</span>(<span class=\"string\">&quot;warning&quot;</span>).<span class=\"built_in\">c_str</span>();</span><br><span class=\"line\">    cout&lt;&lt;c;<span class=\"comment\">//错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这里<code>string(&quot;warning&quot;)</code>是一个临时对象, 在<code>;</code>后就被析构了, 指针<code>c</code>也就悬空了</p>\n<p>首先我们可以肯定的说, 几乎所有时候都需要减少临时对象的产生</p>\n<p>产生临时对象主要有以下几种情况:</p>\n<ol>\n<li>值传递时的函数传参</li>\n<li>类型转换</li>\n<li>函数返回对象</li>\n<li>无名对象</li>\n<li>直接调用构造函数而不命名</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">A</span>()&#123;cout&lt;&lt;<span class=\"string\">&quot;A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">A</span>()&#123;cout&lt;&lt;<span class=\"string\">&quot;~A()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">B</span>():<span class=\"built_in\">price</span>(<span class=\"number\">0</span>)&#123;cout&lt;&lt;<span class=\"string\">&quot;B()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">    <span class=\"built_in\">B</span>(<span class=\"type\">int</span> i):<span class=\"built_in\">price</span>(i)&#123;&#125;</span><br><span class=\"line\">    ~<span class=\"built_in\">B</span>()&#123;cout&lt;&lt;<span class=\"string\">&quot;~B()&quot;</span>&lt;&lt;endl;&#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> price;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">get</span><span class=\"params\">()</span></span>&#123;cout&lt;&lt;price;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>();<span class=\"comment\">//直接调用构造函数而发生的A类类型临时对象</span></span><br><span class=\"line\">    <span class=\"built_in\">string</span>(<span class=\"string\">&quot;上的&quot;</span>);<span class=\"comment\">//无名对象</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i = <span class=\"number\">5</span>;</span><br><span class=\"line\">    i.<span class=\"built_in\">get</span>();<span class=\"comment\">//i自动调用B的构造函数转换为了B类类型,这个转换出来的是临时对象</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["c++知识点"]},{"title":"day11-学习总结","url":"/2022/03/15/day11-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>螺旋矩阵</p>\n<p>双指针及滑动窗口</p>\n<span id=\"more\"></span>\n<h1 id=\"螺旋矩阵I\"><a href=\"#螺旋矩阵I\" class=\"headerlink\" title=\"螺旋矩阵I\"></a>螺旋矩阵I</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">generateMatrix</span>(<span class=\"type\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//显然,n就对应这行数以及列数</span></span><br><span class=\"line\">        <span class=\"comment\">//每转完一圈就会进入行列数减一的完整新圈</span></span><br><span class=\"line\">        <span class=\"comment\">//规定使用左闭右开 [ , ) 12//34//56//78</span></span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">spiral</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(n, <span class=\"number\">0</span>));<span class=\"comment\">//初始化嵌套vector</span></span><br><span class=\"line\">        <span class=\"type\">int</span> top = <span class=\"number\">0</span>, bottom = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left&lt;=right&amp;&amp;top&lt;=bottom) &#123;<span class=\"comment\">//注意条件和与关系</span></span><br><span class=\"line\">            <span class=\"comment\">//等于的时候是单列或单行</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=left; i&lt;=right; i++) &#123;</span><br><span class=\"line\">                spiral[top][i] = count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=top+<span class=\"number\">1</span>; i&lt;=bottom; i++) &#123;</span><br><span class=\"line\">                spiral[i][right] = count++;</span><br><span class=\"line\">            &#125;<span class=\"comment\">//上面的两个区间可以对付单行或单列</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left&lt;right&amp;&amp;top&lt;bottom) &#123;<span class=\"comment\">//只有非单行单列的时候才进行左下两条边的补齐</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=right<span class=\"number\">-1</span>; i&gt;left; i--) &#123;</span><br><span class=\"line\">                    spiral[bottom][i] = count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=bottom; i&gt;top; i--) &#123;</span><br><span class=\"line\">                    spiral[i][left] = count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            top++;left++;</span><br><span class=\"line\">            bottom--;right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> spiral;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"螺旋矩阵II\"><a href=\"#螺旋矩阵II\" class=\"headerlink\" title=\"螺旋矩阵II\"></a>螺旋矩阵II</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">spiralOrder</span><span class=\"params\">(vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt;&amp; matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> max_X = matrix.<span class=\"built_in\">size</span>();<span class=\"type\">int</span> max_Y = matrix[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; result;</span><br><span class=\"line\">        <span class=\"type\">int</span> top = <span class=\"number\">0</span>, bottom = max_X - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = max_Y - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left&lt;=right &amp;&amp; top&lt;=bottom) &#123;<span class=\"comment\">//最核心问题在于单行单列</span></span><br><span class=\"line\">        <span class=\"comment\">//left==right||top==bottom代表单行或单列了,这时候仍然遍历上和右</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=left; i&lt;=right; i++) &#123;</span><br><span class=\"line\">                result.<span class=\"built_in\">push_back</span>(matrix[top][i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=top+<span class=\"number\">1</span>; i&lt;=bottom; i++) &#123;</span><br><span class=\"line\">                result.<span class=\"built_in\">push_back</span>(matrix[i][right]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left&lt;right&amp;&amp;top&lt;bottom) &#123;<span class=\"comment\">//判断非单列单行, 再进行下和左的遍历</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=right<span class=\"number\">-1</span>; i&gt;left; i--) &#123;</span><br><span class=\"line\">                    result.<span class=\"built_in\">push_back</span>(matrix[bottom][i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=bottom; i&gt;top; i--) &#123;</span><br><span class=\"line\">                    result.<span class=\"built_in\">push_back</span>(matrix[i][left]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            left++;right--;top++;bottom--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> slowindex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> fastindex=<span class=\"number\">0</span>; fastindex&lt;nums.<span class=\"built_in\">size</span>(); fastindex++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[fastindex] != val) &#123;</span><br><span class=\"line\">                nums[slowindex] = nums[fastindex];</span><br><span class=\"line\">                slowindex++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slowindex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> slowindex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = INT32_MAX;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> length = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> fastindex=<span class=\"number\">0</span>; fastindex&lt;nums.<span class=\"built_in\">size</span>(); fastindex++) &#123;</span><br><span class=\"line\">            sum += nums[fastindex];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sum &gt;= target) &#123;<span class=\"comment\">//while要找最小子列</span></span><br><span class=\"line\">                length = fastindex - slowindex + <span class=\"number\">1</span>;</span><br><span class=\"line\">                result = result &gt; length ? length : result;</span><br><span class=\"line\">                sum -= nums[slowindex];</span><br><span class=\"line\">                slowindex++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result == INT32_MAX ? <span class=\"number\">0</span> :result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","categories":["leetcode"]},{"title":"day13-学习总结","url":"/2022/03/17/day13-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>list头/尾/中间/依次增添添加元素</p>\n<p>list迭代规则</p>\n<span id=\"more\"></span>\n<h1 id=\"虚拟头结点\"><a href=\"#虚拟头结点\" class=\"headerlink\" title=\"虚拟头结点\"></a>虚拟头结点</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">ListNode* dummyNode = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">-1</span>, <span class=\"literal\">nullptr</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"从头依次添加\"><a href=\"#从头依次添加\" class=\"headerlink\" title=\"从头依次添加\"></a>从头依次添加</h1><p>只需要通过虚拟头结点即可</p>\n<p>新节点指向原dummyNode指向的位置, 新的dummyNode指向新节点</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">ListNode* newNode = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(value);</span><br><span class=\"line\">newNode-&gt;next = dummyNode-&gt;next;</span><br><span class=\"line\">dummyNode-&gt;next = newNode;</span><br></pre></td></tr></table></figure>\n<h1 id=\"从尾部添加一个\"><a href=\"#从尾部添加一个\" class=\"headerlink\" title=\"从尾部添加一个\"></a>从尾部添加一个</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">ListNode* newNode = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(value);</span><br><span class=\"line\">ListNode* cur = dummyNode;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(cur-&gt;next)&#123;</span><br><span class=\"line\">    cur = cur-&gt;next;</span><br><span class=\"line\">&#125;<span class=\"comment\">//令cur指向最后一个元素</span></span><br><span class=\"line\">cur-&gt;next = newNode;</span><br></pre></td></tr></table></figure>\n<h1 id=\"列表逐次添加到尾部\"><a href=\"#列表逐次添加到尾部\" class=\"headerlink\" title=\"列表逐次添加到尾部\"></a>列表逐次添加到尾部</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">ListNode* cur = dummyNode;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(other condition)&#123;</span><br><span class=\"line\">    ListNode* newNode = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(value);</span><br><span class=\"line\">    cur-&gt;next = newNode;</span><br><span class=\"line\">    cur = cur-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"0-Index\"><a href=\"#0-Index\" class=\"headerlink\" title=\"0-Index\"></a>0-Index</h1><ul>\n<li><p>cur是从dummyNode开始的, 列表的序号是dummy, 0, 1, 2,…., n</p>\n</li>\n<li><p>while(index—)是先判断再减, 所以语句会执行index+1次</p>\n</li>\n<li>要想对index的节点操作,需要指向index-1</li>\n</ul>\n<p>以上三点结合, 我们要得到cur = index-1 需要的是从dummyNode开始执行index+1次</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">ListNode* cur = dummyNode;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(index--)&#123;</span><br><span class=\"line\">    cur = cur-&gt;next;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":["leetcode"]},{"url":"/2022/03/21/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E5%8E%BB%E9%87%8D%E5%8E%9F%E5%88%99/","content":"<p>双指针法去重原则</p>\n<p>最后的左右指针使用while</p>\n<p>使用for循环的外部循环将与上一个值相同的去掉</p>\n<p>因为相同的值的话前者会完全遍历, 后者的一定会被遍历到</p>\n<p>条件是<code>i&gt;begin+1</code></p>\n<p>左右指针部分也进行去重,分别判断right和left下一个位置是否相同,相同的话跳过</p>\n"},{"url":"/2022/05/29/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","content":"<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> left = <span class=\"number\">0</span>, right = size - <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(left &lt; right) &#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> mid = right + (left-right)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(nums[mid] 在符合条件的区间中) right = mid;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> left;</span><br></pre></td></tr></table></figure>\n<p>000011111</p>\n<p>有01两个区间,返回1区间的第一个1</p>\n<p>这个模板可以把找确定值转化为区间的第一个, 不如说二分本来就是在找这个</p>\n<p>12345比如找5, 其实在找第一个&gt;=5的位置</p>\n<p>因为第一个也在区间中,所以right不能越过mid</p>\n<p>而不在则可以越过且必须越过,  因为必须让一个边界动起来</p>\n"},{"url":"/2022/04/18/%E7%9B%AE%E5%89%8D%E8%AF%8A%E6%96%AD%E8%84%91%E5%8A%A8%E8%84%89%E7%98%A4%E7%9A%84%E9%87%91%E6%A0%87%E5%87%86%E6%98%AF%E6%95%B0%E5%AD%97%E5%87%8F%E5%BD%B1%E8%A1%80%E7%AE%A1%E9%80%A0%E5%BD%B1%E6%88%90%E5%83%8FDSA/","content":"<p>目前诊断脑动脉瘤的金标准是数字减影血管造影成像DSA</p>\n<p>动脉瘤形态大小位置,协助制定决策</p>\n<p>壁厚和组织病理学特征</p>\n<p>Saccular aneurysms囊状动脉瘤被认为是由血管分支处的后天性或先天性缺陷引起的。这些缺陷之一是缺乏内部弹性层，称为内侧垫缺陷</p>\n<p>3D模型构建-histologic image</p>\n<p>四种颅内动脉瘤壁类型：</p>\n<ul>\n<li>线性组织的平滑肌细胞和完整的内皮细胞</li>\n<li>增厚的壁，有无序增殖的平滑肌细胞，偶尔带有管腔新鲜或组织性血栓</li>\n<li>增厚但脱细胞的前肌内膜增生（MH）或组织性血栓</li>\n<li>非常薄的壁，脱细胞，有组织的管腔血栓。该分类用于之前的动脉瘤模型</li>\n</ul>\n"},{"url":"/2022/03/21/oct/","content":"<p>oct</p>\n<p>OCT的第一个生物医学应用是,  Huang等人于1991年首次在体外对视网膜和冠状动脉的人类毛细血管周围区域进行成像.OCT类似于超声波，但它不使用声波，而是使用低相干光。OCT技术的起源可以追溯到20世纪80年代末电信行业中光学低相干反射计（OLCR）的早期发展。该技术的目的是在微型光波导和光纤中发现故障或反射点。该技术利用宽带光源的短时间相干性，并根据组织类型，对散射组织中的微观结构进行高分辨率、无创的活体成像，深度约为2 mm。迄今为止，OCT最重要的临床影响是在眼科领域，OCT现已被确立为筛查和诊断多种视网膜疾病和青光眼的标准临床成像模式。目前，已有十多家成熟和初创公司参与了眼科OCT市场的增长。心脏病学是OCT可能具有重大临床影响的另一个领域。血管内OCT在描述动脉斑块和可视化介入治疗（如支架植入）方面取得了成功。血管内OCT已经从验证阶段过渡到临床应用。肿瘤学是另一个领域，OCT可能在肿瘤边界检测、图像引导手术和一系列组织中小病灶的早期检测中得到应用。光学相干层析成像是一种基于近红外（nIR）光的成像方式，其中心波长范围为1250至1350  nm。 它测量来自分析组织的nIR光后向散射与来自参考镜的光后向散射的干涉信号。 干扰信号的频率对应于分析组织的深度。 FD分析的引入是血管内OCT临床可行性的一个关键里程碑，因为它显著缩短了OCT成像的时间，并消除了暂时阻断研究节段以清除血液的需要。因此，目前的血管内OCT成像系统仅采用FD分析。 OCT探头由信号发生器（光源）（“扫描激光”）、探测器和参考固定镜组成。nIR光通过光纤从光源传输到探头，探头将光向外并垂直于导管。探头以100圈/秒的频率旋转，允许每秒采集50000条信号轴线。与IVUS获得的图像（100μm）相比，光的使用使OCT能够提供血管壁的高分辨率图像（10–20μm）。然而，光在血管内成像中的应用受到了特殊的限制。血细胞引起近红外光的多次散射及其高信号衰减；因此，OCT成像技术要求在成像期间将血液从血管中取出。此外，近红外光对血管壁的穿透有限，只能在1到3毫米的深度获得信号。ＯＣＴ技术的成像原理类似于超声成像，只是用光波代替了声波，其图像分辨率高于血管超声。 ＯＣＴ技术的成像原理类似于超声成像，只是用光波代替了声波，其图像分辨率高于血管超声。 ＯＣＴ技术的成像原理类似于超声成像，只是用光波代替了声波，其图像分辨率高于血管超声。 </p>\n<p>OCT提供了生物组织的地下微观结构的横截面图。它采用干涉检测和宽带激光来区分不同深度的信号。血管内OCT使用基于光纤的导管将聚焦的激光束传送到血管壁上。通过旋转导管在管腔表面扫描激光光斑，以生成血管的横截面图.OCT通过辨别样品内部不同深度反射的光来测量生物组织的地下微观结构。与超声波成像类似，来自较深结构的信号传播了更长的距离，并延迟到达探测器。声速足够低，可以直接记录样本中各种回声之间的延迟。相比之下，光的传播速度要快得多，无法直接检测到延迟。相反，OCT采用干涉检测，并将样本反射的信号与静态参考信号进行比较。 来自覆盖宽波长光谱的光源的光被分束器分离成参考光和样品臂。生物组织在近红外波段部分透明。因此，探测光通过样本组织传播，并在不同深度被内部结构散射和反射。部分后向散射光将到达探测器，在那里它会干扰来自参考臂的光，而参考臂的光只是从镜子反射回来。探测器将干扰信号转换为电信号，</p>\n<p><img src=\"https://s2.loli.net/2022/03/24/ryYPg3sziuOXjEe.png\" alt=\"image-20220324111715575\"></p>\n<p><img src=\"https://s2.loli.net/2022/03/24/tck3H5sqIrNTEOA.png\" alt=\"image-20220324112149279\"></p>\n<p>ivoct/ivus</p>\n<p>Tearney等人在一项离体研究中首次提出在血管内使用OCT，他们在该研究中证实了OCT能够以足够的分辨率检测与不稳定斑块相关的内膜帽层，并随后开发了一种用于体内的光纤导管（Tearney等人，1997）。OCT在微米级对组织进行无创成像的能力引入了“光学活检”的概念，在这种方法中，可以从成像中获得有关组织的信息，而不是需要组织切除的传统活检（Tearney等人，1997年）。2010年，血管内OCT获得了FDA的冠状动脉成像许可。随后证明，使用OCT指导经皮冠状动脉介入治疗会影响医生在超过一半的病例中做出的决定（Wijns等人，2015年），并降低院内主要不良心脏事件的发生率，与“仅血管造影”病例相比，提高长期存活率（Jones等人，2018年）。</p>\n<p>对于血管内成像，中心波长为1300 nm，范围约为1250至1350  nm是血管成像的最佳“窗口”。血液在近红外范围内是一种高度散射的介质，需要将其从血管腔中移出以形成图像。继早期的时域OCT（TD-OCT）系统之后，提出使用傅里叶域OCT（FD-OCT）来实现更好的灵敏度和高速数据采集。在FD-OCT系统中，分析组织的深度以干扰信号的频率进行编码（Choma等人，2003）。与早期的时域OCT技术（TD-OCT）相比，其主要优势之一在于不需要系统参考臂中的机械扫描部件，从而将OCT成像速度显著提高一个数量级以上。FD-OCT克服了长时间暂时性血管闭塞的需要，允许在短暂的对比剂注射过程中在2秒或更短时间内采集数据，加快了冠状动脉临床应用（Tearney等人，2012年；Tearney等人，2008年）。血管内OCT的空间分辨率使商用IVUS和无创X射线成像技术的分辨率提高了约一个数量级（Tearney等人，2012年）。OCT提供了足够的对比度和信号灵敏度，可以很好地显示软组织和设备，包括血管壁和管腔、斑块成分、解剖以及管壁与植入设备的关系</p>\n<p> 将相干激光束耦合到玻璃纤维中，并以最小的损耗在该纤维中传播光的能力使现代通信技术成为可能.基于导管的成像探头只有在光纤具有灵活性的情况下才有可能实现，并且能够将光信号传递到冠状动脉和从冠状动脉传出。 显示了基于光纤的血管内OCT系统的示意图[2]。携带光源的光纤分为两条光纤，形成采样和参考路径。然后，两个信号都通过光纤循环器传输。这些非互易元件能够有效地将信号中继到样品和参考镜，并将信号从那里反射到检测器。光源技术的发展使OCT成像速度大幅提高。尽管已经证明了A线在MHz范围内的传输速率，但产生的干扰信号的数字化变得具有挑战性[3,4]。此外，在恒定源功率下，扫描速度的增加直接转化为光子数量的减少，并导致信号强度和成像穿透深度的降低。目前商用仪器的A线频率约为100  kHz.所有光源的工作原理是宽带增益介质与波长可调谐滤波器相结合，该滤波器在每一时刻选择一个较窄的波长范围。物理实现的范围很广，从由光纤元件组合而成的光纤源到完全集成的微机电系统（MEMS）。大多数电源产生的输出功率在20-60  mW之间，通常会在组织上产生约8-20 mW的功率。 导管通过与干涉仪的旋转接头连接，并将信号传递至探头尖端和从探头尖端发出信号。它包含一个固定的窄直径（通常为0.87  mm）护套，其中包含旋转探头。探头由单模光纤制成，在其远端尖端，从光纤芯发出的光被反射到侧面，并通过透明护套材料聚焦到管腔表面。旋转接头将干涉仪与导管连接，并定义光学探头的螺旋扫描模式.导管的近端连接到旋转的纤维上。 因为红血球会强烈散射光波，因此会衰减图像，所以OCT需要一个无血场。OCT导管与旋转接头相连，旋转接头使用电机旋转导管中的光纤，并将来自旋转光纤的光与来自参考臂的光耦合。旋转接头安装在自动回拉装置上，从而以螺旋方式扫描动脉。OCT系统有两种类型：时域（图1A）和频域（图1B）。第一代时域？OCT系统要求通过移动参考镜（4）对不同深度的光学回波进行顺序测量。</p>\n<p>冠脉现状</p>\n<p>血管内OCT成像的大部分工作都是在冠状动脉中进行的。血管内成像的重点仍然是血管腔几何结构，它构成了疾病严重性评估（图[A]）和程序治疗指导的主要基础。准确评估管腔-血管/支架界面对于关键测量至关重要，这些测量包括最小管腔面积、管腔阻塞分数、新生内膜增生百分比、支架并置或扩张程度、最小支架横截面积、管腔增益/损耗和再狭窄程度。在过去的十年中，29  OCT已经成为越来越流行的血管内成像方式，提供了管腔和血管壁之间边界的清晰描绘。此外，由于血管壁中没有来自钙的信号干扰，因此它可以应用于指导具有大量浅表钙化的血管的复杂介入手术。29除了评估固有血管系统外，OCT还证明了其在评估冠状动脉内支架置入方面的实用性（图[B]和[C]）。OCT提供的捕捉高分辨率图像的能力和光的物理特性的多功能性将继续提高我们对血管病理学的理解。 正常冠状动脉在OCT上被视为三层结构（图2A）（7）。内部弹性薄片显示为20  mm厚的信号丰富带，位于介质的暗带和外部弹性薄片（7）的进一步信号丰富带内。动脉粥样硬化病变在OCT上表现为动脉壁内的肿块性病变，局部内膜增厚或正常血管结构丧失（8）。纤维斑块产生相对均匀且高度后向散射的信号（8）（图2B）。钙化斑块表现为边界清晰的低信号区（图2C）。OCT于2002年首次在体外验证斑块特征（10）。组织病理学和OCT结果之间的一致性很高（k¼0.83至0.84），观察者之间和观察者内部的可靠性很好.在评估不稳定斑块时，OCT可以检测斑块破裂、侵蚀和冠状动脉内血栓。10,11此外，OCT的高分辨率有可能识别出薄壁纤维粥样瘤（TCFA），其特征是大脂核和薄纤维帽<img src=\"https://s2.loli.net/2022/03/24/xgZ1VPdjybzB47O.png\" alt=\"image-20220324150446821\"></p>\n<p>与血管内超声（IVUS）相比，OCT的分辨率更高，通常能够更好地描绘每个结构，并且能够可靠地显示正常和病变动脉的微观结构。OCT的功能非常适合于识别支架植入后钙化斑块和新生内膜的形成。OCT作为高危病变研究工具的独特功能将很好地服务于心脏病学界，因为它推动我们更好地了解动脉粥样硬化斑块。此外，由于新的OCT技术的发展，OCT已经成为一种引人注目的基于导管的成像技术，可以为临床PCI提供实用指导。与血管内超声（IVUS）相比，OCT的分辨率更高，通常可以更好地描绘每个结构，并且可以可靠地显示正常和病变动脉的微观结构（即，IVUS为15-50微米，而IVUS为150-200微米）。OCT最有价值的挑战之一是它在检测易损斑块方面的作用。心肌梗死、心源性猝死和不稳定型心绞痛由冠状动脉血栓形成引起，而冠状动脉血栓形成主要是由易损斑块破裂引起的。尸检研究已经确定了斑块的几个组织学特征，这些特征与破裂风险和随后的急性冠状动脉事件相关。这些特征包括：（1）一个巨大的坏死核心，上面覆盖着薄纤维帽（&lt;65µm），即所谓的薄纤维粥样瘤（TCFA）；（2）  纤维帽附近活化的巨噬细胞；（3）新生血管[6]。大多数急性冠状动脉事件，包括心肌梗死、不稳定型心绞痛和心源性猝死，都与随后的冠状动脉血栓形成有关 </p>\n<p>OCT最大的优点之一是其高空间分辨率，并且OCT可以精确测量PCI中的病变长度和管腔直径，这有助于优化扩张球囊和支架的尺寸。血管内OCT的成像过程与IVUS类似，只是成像时必须用盐水或对比剂置换血液。</p>\n<p>脑/颈动脉-虹吸弯</p>\n<p>颅外颈动脉的OCT成像由于其不太曲折、更有利的解剖结构，以及使用现有的冠状动脉OCT导管轻松导航的能力而得到了更广泛的研究。对接受颈动脉支架植入术（CAS）的颅外颈动脉狭窄患者进行血管内成像已被证明是安全可行的（Setacci等人，2012年）。OCT成像已被用作CAS期间的辅助手段，以确定斑块形态和成分、斑块脱垂和支架错位（Jones等人，2014年；Shindo等人，2015年；Gnanadesigan等人，2016年）。 </p>\n<p>这也引发了人们对将该技术应用于神经血管内外科领域的兴趣，在该领域，OCT数据有可能彻底改变中风、动脉瘤和其他脑血管疾病的诊断和管理。除了冠状动脉内的应用，OCT最近还被用于评估颅外血管病变，包括动脉粥样硬化、支架置入和解剖</p>\n<p>由于颈动脉位置较深，无创的OCT成像技术在判断颈动脉血管内病变时难度较大。血管内OCT在颅内动脉粥样硬化成像中的首次活体应用是在一名患有椎基底动脉供血不足和颅内椎动脉短段闭塞的患者身上进行的 </p>\n<p>Vikramaditya Prabhudesai[8]在2006年应用 无创的OCT技术在体外对10例切除后的颈动脉 斑块进行检测。通过和病理切片比较发现，在 斑块的外表面进行OCT扫描能够清楚识别斑 块的钙化、胆固醇结晶、脂质沉积等特点，Marco Zimarino等[9]于2007年在新西兰 兔模型中，应用体内OCT技术对14例颈动脉斑 块进行了研究，结果显示体内OCT能够清楚识 别Ⅲ型斑块，但对早期的颈动脉粥样硬化的识 别度有限。2010年，Shinichi Yoshimura等[10] 报道了血管内OCT技术在人体颈动脉系统中的 首次应用，描述了在一名症状性颈动脉狭窄患者中通过OCT检测管腔内血栓，而在IVUS上未发现。</p>\n<p>30这一发现导致管理方式从计划中的颈动脉支架植入术（CAS）转变为颈动脉内膜切除术。标本显示软斑块伴腔内血栓，与术前OCT检查结果相关。此外，Reimers等人31能够从7例有症状和严重并发症的患者的OCT成像初步经验中获得高分辨率图像，包括支架几何形状和斑块覆盖率的信息。Matthews等人32尝试将人类和动物受试者的颈总动脉和颈内动脉的结构组成关联起来。3只猪的颈总动脉在活体TD-OCT、离体TD-OCT和组织病理学之间的血管结构成分表现出良好的相关性。在人体尸体中，ICA海绵状和岩质段的活体图像与离体图像和组织病理学具有可比性，并清楚地显示了血管层。在活体和离体TD-OCT上观察到的血管壁管腔侧的高信号区域，与组织病理学上观察到的中膜弹性蛋白层和平滑肌层相对应，表明活体TD-OCT成像与组织学检查显示的结构信息密切相关。</p>\n<p>OCT对颈动脉夹层的诊断敏感性较高， 可以发现血管内的微小夹层。颈动脉支架置入 过程中，由于受到数字减影血管造影（digital  subtraction angiography，DSA）二维平面成 像的局限性，难以对支架的释放情况、支架与 血管内膜之间的关系进行直观评估。OCT所采 用的近红外线光源，不能透过含有金属的支架 支撑杆，因此支架支撑杆在图像上表现为支架 内壁反射产生的高亮度散乱光，支架支撑杆背 面有反射阴影。OCT图像的高分辨率使CAS后 的支架贴壁不良、支架扩张不全、内膜组织脱 垂等常见情况得以清晰呈现.支架贴壁不良是指支架支撑杆与血管壁之 间的分离，可引起局部血流涡流，增加亚急性 血栓的风险[22]。支架贴壁不良也可以延迟损伤 血管的愈合过程，导致后期血栓形成。OCT图 像可以通过测量支架支撑杆的中间部位离血管 壁的距离来判断支架贴壁是否良好。颈动脉夹层也是较为多见的颈动脉 病变。OCT对颈动脉夹层的诊断敏感性较高， 可以发现血管内的微小夹层。OCT可在介入手术中轻 松并入，术者无须接受较多的附加培训。这使 得OCT技术在颈内动脉系统的应用有着广阔 的前景</p>\n<p>.以前，在大口径、高流量颈动脉中使用OCT获得高分辨率图像的一个主要挑战是血液清除率不足，需要近端血管阻塞才能获得满意的图像。与FD-OCT发展相关的更快的回缩速度能够在缩短的成像采集期内实现充分的血液清除，并避免近端闭塞的需要。其更大的视野也有助于更大动脉的成像，如ICA。Jones等人33报道，4例无症状颈动脉疾病患者通过FD-OCT获得的所有横断面图像中，97%适合分析。同样，Attizzani等人28日在没有近端球囊闭塞的情况下使用FD-OCT，能够获得满意的图像，用于分析2例CAS后出现晚期血管反应的患者。 了解和可视化这些独特的颅内形态特征的最准确方法是组织学研究。利用高分辨率血管壁磁共振成像（Turan等人，2014年；MossaBasha等人，2016年）对颅内动脉粥样硬化疾病的特征进行了研究。相对于目前可用的其他成像方式，OCT的更高空间分辨率可以描绘血管壁病理，评估斑块形态、成分、破裂和侵蚀，其细节类似于组织学分析.尸检研究表明，OCT可以高灵敏度地识别纤维帽内巨噬细胞密度大于10%的斑块，并可以检测代表新生血管的微通道，在薄帽斑块和斑块破裂患者中发现的新生血管数量更高（Abtahian和Jang，2012）。还提出了将OCT与光谱学和荧光技术相结合的多模态血管内成像方法（Gardner等人，2008年；Ughi等人，2016年；Verjans等人，2016年；Hara等人，2017年）。 在动物模型和人类尸体上对颅外和颅内颈动脉进行的血管内OCT显示，在动脉段的表征方面，活体、离体和组织学样本之间存在极好的相关性（Mathews等人，2011年；Ughi等人，2020年）。已经证明，OCT在斑块表征（Yabushita等人，2002年）、检测各种类型的冠状动脉钙化（Saita等人，2017年）以及检测正常血管的内膜、中层和外膜层（Kume等人，2005年）方面与组织学高度一致。与IVUS相比，威利斯环（Weigand  et al.，2019）和冠状动脉（Jang et  al.，2002）处斑块的死后OCT成像在描述纤维化和钙化斑块以及将其与坏死、富含脂质斑块区分开来方面似乎更具优势。与传统血管造影相比，OCT可以提供更精确的血管直径测量，以及病变血管段的精确长度，有助于更准确地确定支架尺寸.颅内动脉夹层是另一个众所周知的导致管腔狭窄的原因，由于小口径或颅内血管，且缺乏特定的放射学征象，诊断具有挑战性。导致管腔狭窄的病理性壁内血肿可被误诊为动脉粥样硬化病变（Park等人，2017年）。一例急性基底动脉血栓形成被认为与潜在狭窄有关，经OCT成像确认为夹层。病变支架植入后，进行了OCT成像，发现了动脉剥离的典型表现，如内膜瓣、双腔和壁血肿，这些血肿起源于椎动脉，并向远端延伸至基底动脉（Gao等人，2018年）。在动物模型中使用OCT进行解剖表征的示例如图3所示。 </p>\n<p><img src=\"https://s2.loli.net/2022/03/24/FuBeTZVkUb1846Y.png\" alt=\"image-20220324171127347\"></p>\n<p><img src=\"https://s2.loli.net/2022/03/24/Y5LqwlQtKSi9Vx6.png\" alt=\"image-20220324171818088\"></p>\n<p>国内</p>\n<p>南京军区南京总医院神经内科研究小组 在2015年报道了基于OCT观察颈动脉脂质斑 块对支架贴壁情况的影响.既往研究中，ＯＣＴ在脑血管系统中的应用部位包括颅外段和颅内段。目前颅外段血管如颈内动脉窦部、颈段、岩段、椎动脉起始部应用较多，颅内段血管如颈动脉颅内段及基底动脉也有应用报道［４，６１７］。对于大脑中动脉Ｍ１段及以远，基于目前的ＯＣＴ导管，仅有动物及尸体研究报道，尚未成功应用于临床［７］。由于ＯＣＴ成像导管的设计是基于冠状动脉，在迂曲的脑血管中应用时，存在一定的局限性。对于严重迂曲的血管，反复尝试可导致光学透镜损坏、血管损伤等［１６，１８］。此外，迂曲的脑血管可导致血管冲洗不良或产生不均匀旋转伪像，必要时需重复成像或加大冲洗速率［１８］。在颅内血管成像时，必要时可配合中间导管使用［５］。目前，ＯＣＴ技术可观察的血管直径范围为７ｍｍ左右，穿透深度为０．１～２．０ｍｍ［２］，对于巨大的动脉瘤、管径偏大的血管、脂质或者血栓覆盖下的血管壁等无法完全成像。 </p>\n<p>国外</p>\n<p>除了冠状动脉内的应用，OCT最近还被用于评估颅外血管病变，包括动脉粥样硬化、支架置入和解剖（图[D]）。Y  oshimura在一份病例报告中首次报道了OCT成像在颈内动脉（ICA）中的应用，该病例报告描述了在一名症状性颈动脉狭窄患者中通过OCT检测管腔内血栓，而在IVUS上未发现。30这一发现导致管理方式从计划中的颈动脉支架植入术（CAS）转变为颈动脉内膜切除术。标本显示软斑块伴腔内血栓，与术前OCT检查结果相关。此外，Reimers等人31能够从7例有症状和严重并发症的患者的OCT成像初步经验中获得高分辨率图像，包括支架几何形状和斑块覆盖率的信息 .OCT的使用导致手术时间延长了16±12分钟，只有1名患者出现短暂的意识丧失≈OCT和ICA血流阻断期间3分钟，无持续的神经后遗症。在随后一项比较OCT和IVUS检测CAS的研究中，Y  oshimura等人报告了使用OCT检测管腔内血栓和新生血管的优越检出率。作者还证明，在报告OCT诊断血栓、新生血管、溃疡和脂质池时，观察者之间和观察者之间存在极好的变异性。 为了用离体TD-OCT和常规组织病理学验证活体TD-OCT数据，Matthews等人32尝试将人类和动物受试者的颈总动脉和颈内动脉的结构组成关联起来。3只猪的颈总动脉在活体TD-OCT、离体TD-OCT和组织病理学之间的血管结构成分表现出良好的相关性。在人体尸体中，ICA海绵状和岩质段的活体图像与离体图像和组织病理学具有可比性，并清楚地显示了血管层。在活体和离体TD-OCT上观察到的血管壁管腔侧的高信号区域，与组织病理学上观察到的中膜弹性蛋白层和平滑肌层相对应，表明活体TD-OCT成像与组织学检查显示的结构信息密切相关。已有一些神经介入手术中血管内OCT的临床病例报告，显示了颅内动脉粥样硬化性疾病治疗的特点，31根据支架辅助动脉瘤缠绕进行血管重塑，32并描绘了颈部颈动脉创伤性动脉瘤的病理生理学特征。33然而，血管内OCT在神经介入手术中的应用在很大程度上仅限于研究临床前外周血管模型、具有特殊准备的人类尸体、28,34或涉及颅外循环的临床病例中的神经血管装置。这是因为OCT导管的外形和硬度都比用于弯曲脑血管系统的设备高得多。 </p>\n<p>OCT已被用于评估不同支架设计的斑块脱垂，并表明使用重叠支架可显著减少不稳定斑块患者的组织脱垂 .它已被用于诊断颈动脉支架术后支架内再狭窄，其中OCT可显示严重的纤维化新生内膜生长和球囊血管成形术后剥离动脉的内膜破裂</p>\n<p>分析—脑血管疾病-风险-</p>\n<p>颅内动脉夹层（IAD）的诊断可能具有挑战性，通常需要多模式成像技术来确认诊断。以前的研究都是基于常规血管造影、计算机断层扫描或磁共振成像来诊断IAD。我们报告了一例由于自发性基底动脉剥离导致的急性缺血性中风，其中血管内光学相干断层扫描（OCT）被用来显示IAD的特征。CAS后的OCT研究表明，在富含脂质的斑块、斑块脱垂和纤维帽破裂中，嵌入支架支柱更常见.OCT可以提供详细的信息，可以改变DSA对斑块突出的管理和评估 .当OCT成像发现斑块突出、血栓和支架扩张/并置不完全时，可提示进一步介入血管成形术、部署第二个支架和/或开始更积极的抗血小板和抗凝治疗 .</p>\n<p>囊状动脉瘤是最常见的，占所有颅内动脉瘤的90%，其中85%起源于Willis环动脉 现有的成像方式无法描述对动脉瘤演变至关重要的显微解剖学特征，也无法全面评估治疗病变的愈合过程。根据对威利斯环的尸检研究，OCT被用于研究血管结构和相关组织学检查后出现的血管壁异常。内膜瓣、内膜厚度、穿支、分支和血管壁的所有层都清晰可见。OCT成像血管壁及其各层细微结构变化的能力也可以应用于颅内动脉瘤，因为它是预测动脉瘤进展和破裂的病理变化发生的地方.OCT评估人类颅内动脉结构的能力也通过三名患者的颈内动脉成像得到了临床验证 在人类尸体上首次使用商用OCT导管使用标准血管内技术评估颅内血管，显示了MCA、Acom复合体和基底动脉穿支的组织学可视化，以及支架支柱与部署在基底动脉的管道装置的血管壁和穿支起点的关系。了解不同位置的穿支密度有助于支架部署的最佳位置以及支架的选择（Lopes和Johnson，2012）。首次对人类颅内血管进行活体OCT研究是在一名患有颅内盘绕动脉瘤的患者身上进行的，该患者使用定制的OCT导管在动脉瘤颈部导航（Su等人，2008年）。首次使用OCT观察弹簧圈栓塞后动脉瘤颈部水平的变化是在离体犬模型上进行的，与愈合相关的变化与组织学密切相关（Thorell  et al.，2005）。 对弹性蛋白酶诱发动脉瘤的兔子进行的血管内OCT成像显示，经组织学证实的内外板完全消失，而人类颅内动脉瘤的血管外OCT显示破裂和未破裂动脉瘤的结构成分不同，破裂的动脉瘤壁结构完全破裂，正常层消失，而未破裂的动脉瘤表现出退化，层间界限逐渐丧失（Liu等人，2019b）。在一项类似的研究中，血管外OCT能够描绘出载瘤动脉和颅内动脉瘤的微观结构组成，可以显示临床相关特征，如厚度、钙化、残余中膜和动脉粥样硬化斑块（Hartmann  et al.，2019）。 到目前为止，OCT对动脉瘤的研究主要集中在设备壁相互作用和动脉瘤愈合方面。临床前动物模型（Iosif等人，2016年；Matsuda等人，2018b；Caroff等人，2020年）和尸体（Matsuda等人，2018a）中已充分记录了植入装置（主要是分流装置）的新内膜形成。还评估了血管-壁-装置之间的相互作用，以及穿支或被囚禁分支的组织形成和通畅性。这再次证明，OCT不仅能够评估和跟踪治疗动脉瘤的愈合过程，提供关于可能需要再治疗或抗血小板治疗持续时间的重要信息，而且还能够描绘血管壁层发生的细微变化。OCT可以提供动脉瘤结构的详细信息，可以进一步了解颅内动脉瘤的微观结构，更好地评估动脉瘤破裂和进展的风险。 目前商用OCT系统的导航能力已在具有不同解剖结构类型的前循环3D打印硅胶模型中进行了测试，结果表明，颈部ICA和颈动脉虹吸的不良扭曲解剖结构是导航失败的预测因素（Martinez-Galdamez  et al.，2019）。 同一组患者试图在Pcom水平上对动脉瘤进行分流治疗，但未能将OCT系统导航至支架区的远端，并且未能对整个所需血管段进行连续成像。其他作者也报道了同样的问题，同样位置的动脉瘤，由于无法导航到颈动脉虹吸的远端，只能对近端支架末端进行成像 .在后循环中，由于更有利的解剖结构和更少的血管急性成角，两名患者在支架辅助缠绕治疗椎动脉瘤后，可以进行OCT探查。成功评估了支架并置、支架内皮化和颈部新生内膜形成（Yako等人，2017年）。 </p>\n<p>在冠状动脉中，血管内成像已经被广泛应用了几十年。虽然这两种不同血管床之间潜在疾病的病理生理过程相似，但解剖特征可能存在显著差异。颅内血管被脑脊液包围，脑脊液在光学上是透明的，可以对血管壁及周围组织和结构进行最佳可视化。然而，脑血管树的高度扭曲的解剖结构对商用快速交换OCT导管的导航提出了无法克服的挑战，该导管设计用于冠状动脉，尤其是在颈动脉虹吸远端的前循环中。此外，冠状动脉OCT导管的外形和刚度不符合在曲折的颅内循环中安全可靠使用所需的技术特征。现有冠状动脉OCT系统的其他局限性是相对狭窄的视野，不适合对较大的颅内动脉和动脉瘤进行成像，并且帧间距不足以对小结构（如穿通动脉和小型设备支架）进行精确采样。引入了新一代血管内FD-OCT技术，名为高频OCT（HF-OCT）（Ughi等人，2020年）。HF-OCT成像导管专为神经血管应用而设计，其1.2F剖面与0.01700微导管兼容，具有所需的灵活性，并结合了适当的技术解决方案，以在严重扭曲的血管路径中实现最佳协商和无伪影成像（Carniato等人，2013年；Ughi等人，2020年）。此外，它的视野增大，半径约为7  mm（成像直径为14 mm），在正确定位时，可以洞察大型动脉瘤的血管壁。每秒250张图像的快速成像速度可以在2秒内以密集帧间距（Gounis）对长动脉段进行成像  这项新技术显示出对神经血管成像的巨大优势（Ughi等人，2020年），并显示出在不久的将来在颅内血管系统中进行临床翻译的潜力。 </p>\n<p>大多数脑血管疾病和潜在的治疗与血管壁和管腔密切相关。一种能够提供疾病进展的新见解、评估与手术相关的事件以及监测愈合过程的成像设备，在任何意义上对该领域都是无价的。OCT在脑血管疾病的评估中显示出巨大的潜力，并具有预测自然史和预后的潜力。此外，它还可以成为评估和选择适合介入治疗的病变的宝贵工具，最大限度地减少可能的并发症。</p>\n<p>p30</p>\n<p>4-10</p>\n<p>2486Ay2[</p>\n"}]