[{"title":"Day1 学习总结","url":"/2022/02/25/Day1-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>摘要:①搞好了blog的一些显示问题,主要是使用了html标签的方式.</p>\n<p>​            ②找到了vis-M的专利.</p>\n<span id=\"more\"></span>\n<h4 id=\"上午10-00-11-45\"><a href=\"#上午10-00-11-45\" class=\"headerlink\" title=\"上午10:00-11.45\"></a>上午10:00-11.45</h4><ul>\n<li>[x] 搞好hexo的markdown渲染问题,熟悉一下Typora快捷键</li>\n<li>[x] 做一下下午的规划</li>\n</ul>\n<h2 id=\"hexo遗留问题\"><a href=\"#hexo遗留问题\" class=\"headerlink\" title=\"hexo遗留问题\"></a>hexo遗留问题</h2><p>三个额外的渲染需要用html标签实现了,高亮使用代码高亮或者<font color=\"#FF2222\">改变字体颜色</font>使用的是html语法</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">color</span>=<span class=\"string\">&quot;#十六进制色号&quot;</span>&gt;</span> <span class=\"tag\">&lt;/<span class=\"name\">font</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><mark>mark标签高亮显示文本</mark></p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">mark</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">mark</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>cm<sup>3</sup>  H<sub>2</sub>O</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">sup</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">sup</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">sub</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">sub</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>选中一整行是<mark>ctrl+L</mark></p>\n<p>选中单词是<mark>ctrl+D</mark></p>\n<p>hexo的文章摘要标记是:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure>\n<p>顺带一提把搜狗输入法的中文输入时的标点改为了英文</p>\n<p>网页背景更改:\\themes\\next\\source\\css_schemes\\Gemini\\index.styl下添加如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">body &#123; </span><br><span class=\"line\">\tbackground: url(/images/background.jpg);</span><br><span class=\"line\">\tbackground-repeat: no-repeat;// 设定背景图片非重复填充</span><br><span class=\"line\">\tbackground-attachment: fixed;// 设置背景图片不随页面滚动</span><br><span class=\"line\">\tbackground-position: 20% 20%;// 设置背景图片位置</span><br><span class=\"line\">\tbackground-size: cover//</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"下午规划\"><a href=\"#下午规划\" class=\"headerlink\" title=\"下午规划\"></a>下午规划</h3><ul>\n<li>[x] 把essential c++前三章好好看一下,对照之前写的码</li>\n<li>[x] 找一找光纤柔韧性(医学)相关的东西</li>\n<li>[ ] 找个c++的leetcode讲解不行在看左程云做一下刷题计划</li>\n</ul>\n<h2 id=\"柔性光纤文献思路\"><a href=\"#柔性光纤文献思路\" class=\"headerlink\" title=\"柔性光纤文献思路\"></a>柔性光纤文献思路</h2><p>flexible fiber bundle (FB)柔性光纤束</p>\n<p>这种东西是前向成像oct?但是似乎不需要旋转,他能不能用作iv成像.目前的两个关键参数:<mark>直径-柔韧性</mark>看一下参考文献fiber bundle/endoscopy</p>\n<p>居然连国内都有一家申请了专利,使用的是所谓弯曲不敏感型光纤(光纤直径为80um ~ 120um，光纤最小弯曲半径5 ~ 12mm)</p>\n<p>找到了vis-M的专利 <mark>☆</mark></p>\n<p><a href=\"https://patents.glgoo.top/\">谷歌专利查询</a>查询Gentuity—-imaging system with optical pathway</p>\n<p>明天详细看一看</p>\n<h2 id=\"c-复习-DAY1\"><a href=\"#c-复习-DAY1\" class=\"headerlink\" title=\"c++复习 DAY1\"></a>c++复习 DAY1</h2><h3 id=\"1-基本内置类型\"><a href=\"#1-基本内置类型\" class=\"headerlink\" title=\"1.基本内置类型\"></a>1.基本内置类型</h3><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">位(字节)</th>\n<th>范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">bool</td>\n<td style=\"text-align:center\"></td>\n<td>true/false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">char</td>\n<td style=\"text-align:center\">1</td>\n<td>0~255</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">4</td>\n<td>-214783648~214783647</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">float</td>\n<td style=\"text-align:center\">4</td>\n<td>+/- 3.4e +/- 38 (~7 个数字)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">double</td>\n<td style=\"text-align:center\">8</td>\n<td>+/- 1.7e +/- 308 (~15 个数字)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>修饰符:</p>\n<p>signed/unsigned; short/long</p>\n<ul>\n<li><p>无符号类型变成从0开始</p>\n</li>\n<li><p>long修饰符占字符位×2; short修饰符占字符位÷2</p>\n</li>\n<li><p>一个字节占8个byte</p>\n</li>\n</ul>\n<p>注意无符号类型在循环条件中永远不会小于0的问题</p>\n<h3 id=\"2-变量初始化与作用域\"><a href=\"#2-变量初始化与作用域\" class=\"headerlink\" title=\"2.变量初始化与作用域\"></a>2.变量初始化与作用域</h3><p>Type name = value;  或Type name{value};</p>\n<p>extern关键字表示不初始化的声明变量</p>\n<p>在函数或代码块内部声明的为局部变量</p>\n<p>在函数外部声明的为全局变量</p>\n<p>在函数参数的定义中声明的为形式参数</p>\n<h3 id=\"3-复合类型-引用与指针\"><a href=\"#3-复合类型-引用与指针\" class=\"headerlink\" title=\"3.复合类型-引用与指针\"></a>3.复合类型-引用与指针</h3><p>这里的引用只介绍左值引用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ival = <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;ref_ival = ival;</span><br><span class=\"line\"><span class=\"type\">int</span> &amp;ref_ival2;<span class=\"comment\">//错误的,引用必须进行初始化</span></span><br></pre></td></tr></table></figure>\n<p>引用只是初始化对象的一个别名,它并不是一个真实存在的对象,因此也<mark>无法更改绑定对象</mark>; 无法定义引用的引用;  必须进行初始化(这三点是与指针的关键不同)</p>\n<p>对引用对象一切操作都是对原地址的操作</p>\n<hr>\n<p>​        指针(pointer)本质可以理解为一类数据类型, 在基本数据类型加 * 定义对应指针类型.</p>\n<p>允许对指针的赋值/拷贝/更改指向对象/无初始化(不要这么做)/定义指向其本身的指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* ptr = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"><span class=\"type\">double</span> dp, *dp2;<span class=\"comment\">//dp是double,dp2是指向double的指针类型</span></span><br><span class=\"line\"><span class=\"comment\">//最好不要这么写</span></span><br><span class=\"line\"><span class=\"type\">int</span> *p1, p2;<span class=\"comment\">//p1是指针而p2是int</span></span><br><span class=\"line\"><span class=\"comment\">//说实话写成int* p1要更好一些</span></span><br></pre></td></tr></table></figure>\n<p>取地址符 &amp; 取出变量的地址</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ival = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> *ptr = &amp;ival;</span><br></pre></td></tr></table></figure>\n<p>解引用符 *  得到指向的对象本身</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; *ptr; <span class=\"comment\">//输出1</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意取地址符与解引用符与数据类型定义时的引用与指针<mark>没有任何关系</mark></li>\n</ul>\n<p>指针的引用:(test)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> ival = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>* ptr;</span><br><span class=\"line\"><span class=\"type\">int</span>* &amp;ref = ptr;</span><br><span class=\"line\">ref = &amp;ival;</span><br><span class=\"line\">*ref = <span class=\"number\">0</span>;</span><br><span class=\"line\">cout&lt;&lt;ival;<span class=\"comment\">//输出什么?</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-const与constexpr\"><a href=\"#4-const与constexpr\" class=\"headerlink\" title=\"4.const与constexpr\"></a>4.const与constexpr</h3><p>const修饰的变量不能改变内容</p>\n<p>可以将一个非const对象绑定到const修饰的引用上(反过来不行),这样就无法通过ref来修改(用来传参)</p>\n<p>当然const也能修饰指针,一个const类型的指针也必须用const修饰</p>\n<p>当然也可以用const指针指向一个非const变量,这样指针本身不能动但是可以修改其指向的对象</p>\n<p>常量表达式(const expression)</p>\n<p>当你确定后面的表达式/函数是一个const(不会改变)的时候就用constexpr修饰定义</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> mf = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"type\">int</span> limit = mf+<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-typedef与auto\"><a href=\"#5-typedef与auto\" class=\"headerlink\" title=\"5.typedef与auto\"></a>5.typedef与auto</h3><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> wage;</span><br><span class=\"line\">wage ival = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"type\">int</span> wage;<span class=\"comment\">//等价写法</span></span><br></pre></td></tr></table></figure>\n<p>auto修饰符会自己根据初始化判断数据类型</p>\n<h3 id=\"6-struct-建议直接class\"><a href=\"#6-struct-建议直接class\" class=\"headerlink\" title=\"6.struct//建议直接class\"></a>6.struct//建议直接class</h3><p>自定义数据类型</p>\n","categories":["日志"],"tags":["c++语法","markdown语法","柔性光纤"]},{"title":"day3-学习总结","url":"/2022/02/28/day3-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>矩阵分析,代码随想录2章</p>\n<p>递归算法的时间复杂度与空间复杂度</p>\n<p>递归算法的读法与写法</p>\n<span id=\"more\"></span>\n<h1 id=\"递归算法的写法\"><a href=\"#递归算法的写法\" class=\"headerlink\" title=\"递归算法的写法\"></a>递归算法的写法</h1><p>数学归纳法:</p>\n<p>1.确定递归变化量和每次的变化规则<strong>(函数参数和参数变化规则)</strong></p>\n<p>2.通过递归式得到a<sub>n-1</sub>的结果, 既我们假设除了最后一步计算都业已完成</p>\n<p>3.得到由a<sub>n-1</sub>到a<sub>n</sub>的计算步骤, 并返回结果</p>\n<p>4.因为数学归纳法,由a<sub>n-2</sub>到a<sub>n-1</sub>的计算是一样的所以递归式成立</p>\n<p>5.写出起始/终止 时的边界返回结果</p>\n<p>例: 反转链表</p>\n<p><img src=\"https://s2.loli.net/2022/02/28/XoFJ4zjYLiBsHuy.png\" alt=\"\"></p>\n<ol>\n<li><p>我们先<mark>假设n-1个链表已经反转完成了</mark></p>\n</li>\n<li><p>我们在遇到递归时,不要想这个里面是怎么递归的,直接把他认为一个黑箱已经帮我们得到了F(n-1)的结果</p>\n<p>本质上是把<mark>用现状态表示的下一个状态</mark>传给函数,循环往复</p>\n</li>\n<li><p>所以我们得到了除了1节点未完成的链表newhead, 如图</p>\n</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode <span class=\"title\">F</span><span class=\"params\">(ListNode head)</span></span>&#123;</span><br><span class=\"line\">\tListNode newhead = <span class=\"built_in\">F</span>(head.next);</span><br><span class=\"line\">    <span class=\"comment\">//现在newhead指向5, head依旧指向1</span></span><br><span class=\"line\">    <span class=\"comment\">//head用完就要抛弃了</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://s2.loli.net/2022/02/28/lWMDuk5LiYsKnhR.png\" alt=\"2\"></p>\n<ol>\n<li>然后对应的调整好指针</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ListNode <span class=\"title\">F</span><span class=\"params\">(ListNode head)</span></span>&#123;</span><br><span class=\"line\">\tListNode newhead = <span class=\"built_in\">F</span>(head.next);</span><br><span class=\"line\">\thead.next.next = head.next;</span><br><span class=\"line\">\thead.next = null;</span><br><span class=\"line\">\tretrun newhead;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>边界条件</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(head == null || head.next == null) <span class=\"comment\">//也要防止本身链表就是空的</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> head;</span><br></pre></td></tr></table></figure>\n<h1 id=\"递归时间复杂度\"><a href=\"#递归时间复杂度\" class=\"headerlink\" title=\"递归时间复杂度\"></a>递归时间复杂度</h1><p>递归可以抽象成满二叉树,每个节点代表一次递归</p>\n<p>O(叶子节点数 * 每次的时间复杂度)</p>\n<p>满二叉树的叶子数为<mark>2<sup>m+1</sup>-1</mark>, m为深度m=<mark>log<sub>2</sub><sup>n</sup>-1</mark></p>\n","categories":["日志"]},{"title":"day2-学习总结","url":"/2022/02/27/day2-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>摘要: </p>\n<p>①string和vector的基础使用</p>\n<p>②迭代器初识</p>\n<p>③循环条件问题</p>\n<span id=\"more\"></span>\n<h1 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::string;</span><br></pre></td></tr></table></figure>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">string s = <span class=\"string\">&quot;value&quot;</span>;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">&quot;value&quot;</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"string\">&quot;c&quot;</span>)</span></span>;<span class=\"comment\">//&quot;ccc&quot;</span></span><br></pre></td></tr></table></figure>\n<p>1称之为拷贝初始化,2,3为直接初始化</p>\n<h2 id=\"string操作\"><a href=\"#string操作\" class=\"headerlink\" title=\"string操作\"></a>string操作</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">&quot;value&quot;</span>)</span></span>;</span><br><span class=\"line\">os &lt;&lt; s;</span><br><span class=\"line\">is &gt;&gt; s;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(is, s);</span><br><span class=\"line\">s.<span class=\"built_in\">empty</span>();<span class=\"comment\">//true or false</span></span><br><span class=\"line\">s.<span class=\"built_in\">size</span>();<span class=\"comment\">//注意他返回一个无符号类型std::size_type</span></span><br><span class=\"line\">s[n];<span class=\"comment\">//0~n-1</span></span><br><span class=\"line\">s2 = s;</span><br><span class=\"line\">s3 = s + s2;<span class=\"comment\">//得到拼接后的结果</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(s2 == s);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(s2 != s3);</span><br><span class=\"line\"><span class=\"comment\">//&lt;,&lt;=,&gt;,&gt;= 按照字典中的顺序比较</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"读写\"><a href=\"#读写\" class=\"headerlink\" title=\"读写\"></a>读写</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">string word;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(cin &gt;&gt; word) cout &lt;&lt; word &lt;&lt;endl;</span><br></pre></td></tr></table></figure>\n<p>使用getline()函数可以得到第一个参数的第一行(不带换行符)赋予第二个参数</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">string line;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"built_in\">getline</span>(cin, line))</span><br><span class=\"line\">    cout&lt;&lt;line&lt;&lt;endl;</span><br></pre></td></tr></table></figure>\n<h3 id=\"关于字符串与字面值相加\"><a href=\"#关于字符串与字面值相加\" class=\"headerlink\" title=\"关于字符串与字面值相加\"></a>关于字符串与字面值相加</h3><p><mark>这是个坑</mark></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">s = <span class=\"string\">&quot;hello &quot;</span> + <span class=\"string\">&quot;world&quot;</span>;<span class=\"comment\">//错误的</span></span><br><span class=\"line\">s = <span class=\"string\">&quot;hello &quot;</span>;s2 = s +<span class=\"string\">&quot;world&quot;</span>;<span class=\"comment\">//正确的</span></span><br></pre></td></tr></table></figure>\n<p>因为字面值字符串与c兼容并不是std::string 类型的, 他们是没有+这种操作的</p>\n<p>所以必须有一个string类型在里面</p>\n<h3 id=\"字符类型判断\"><a href=\"#字符类型判断\" class=\"headerlink\" title=\"字符类型判断\"></a>字符类型判断</h3><p>见c++ prime P82,3-2</p>\n<h3 id=\"c-11遍历操作\"><a href=\"#c-11遍历操作\" class=\"headerlink\" title=\"c++11遍历操作\"></a>c++11遍历操作</h3><ol>\n<li>只读</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">&quot;something&quot;</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c : s)&#123;</span><br><span class=\"line\">    cout &lt;&lt; c &lt;&lt; <span class=\"string\">&quot;\\n&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>改变原字符串 &amp;</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> &amp;c : s)&#123;<span class=\"comment\">//c为引用,原址操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c == <span class=\"string\">&quot;s&quot;</span>) c = <span class=\"string\">&quot;*&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">cout &lt;&lt; s;</span><br></pre></td></tr></table></figure>\n<h1 id=\"vector\"><a href=\"#vector\" class=\"headerlink\" title=\"vector\"></a>vector</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> std::vector;</span><br></pre></td></tr></table></figure>\n<h2 id=\"初始化-1\"><a href=\"#初始化-1\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector &lt;T&gt; v1;</span><br><span class=\"line\">vector &lt;T&gt; v1&#123;a,b,c&#125;;</span><br><span class=\"line\">vector &lt;T&gt; v1 = &#123;a,b,c&#125;;</span><br><span class=\"line\">vector &lt;T&gt; v2 = v1;</span><br><span class=\"line\">vector &lt;T&gt; <span class=\"built_in\">v2</span>(v1);</span><br><span class=\"line\">vector &lt;T&gt; <span class=\"built_in\">v3</span>(n, val);<span class=\"comment\">//n个重复val</span></span><br><span class=\"line\">vector &lt;T&gt; <span class=\"built_in\">v4</span>(n);<span class=\"comment\">//只是初始化n占位</span></span><br></pre></td></tr></table></figure>\n<p>注意()和{}, ()代表的是构造对象,里边是两个参数, {}是列表初始化,里边是实实在在的list</p>\n<h2 id=\"添加元素-push-back\"><a href=\"#添加元素-push-back\" class=\"headerlink\" title=\"添加元素 push_back\"></a>添加元素 push_back</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector &lt;T&gt; v;</span><br><span class=\"line\">v.<span class=\"built_in\">push_back</span>(value);</span><br></pre></td></tr></table></figure>\n<p>用法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i &lt;= n; ++i)&#123;</span><br><span class=\"line\">    v.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"type\">const</span> vector&lt;T&gt; &amp;vec)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> c : vec) cout&lt;&lt;c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>for range型内不能进行push_back(),因为range不能在循环中发生改变</p>\n</li>\n<li><p>在<mark>添加或删除容器的内容后</mark>,所有的指针以及迭代器都失效了</p>\n</li>\n</ol>\n<p>注: for语句执行顺序-<mark>先判断再执行</mark></p>\n<p>初始赋值-&gt;初次判断-&gt;语句执行-&gt;表达式迭代-&gt;判断-&gt;执行-&gt;迭代…..</p>\n<p>也就是说,在写的时候只需要确定三个东西</p>\n<ol>\n<li><p>初始位置    [start, ….</p>\n</li>\n<li><p>迭代步长</p>\n</li>\n<li><p>终止位置    终止可以选择闭区间 <mark>&lt;= </mark>或是开区间 &lt;mark><</mark> </p>\n</li>\n<li><p>当使用的是&lt;=时,区间为[start, end]</p>\n<p> 当使用的是&lt;时,区间为[start, end)</p>\n</li>\n</ol>\n<p>推荐使用前闭后开,因为数组序号是0~n-1的,所以迭代[0, n)等价于[0,n-1]</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;n; ++i) statement;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;=n<span class=\"number\">-1</span>; ++i) statement;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">v.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">v.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">v[n];<span class=\"comment\">//注意不能想超限的位置添加元素</span></span><br><span class=\"line\">v1 = v2;</span><br><span class=\"line\">v1 == v2;<span class=\"comment\">//!= &lt; &gt; &lt;= &gt;=</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"迭代器-iterator\"><a href=\"#迭代器-iterator\" class=\"headerlink\" title=\"迭代器 iterator\"></a>迭代器 iterator</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> begin = v.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"keyword\">auto</span> end = v.<span class=\"built_in\">end</span>();</span><br></pre></td></tr></table></figure>\n<p>begin指向第一个元素,end指向最后一个元素的<mark>下一个元素</mark></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">*iter;<span class=\"comment\">//解引用,注意得到的是原址对象</span></span><br><span class=\"line\">iter-&gt;mem;<span class=\"comment\">//等价于*(iter).mem</span></span><br><span class=\"line\">++iter;--iter;</span><br><span class=\"line\">iter == iter2;</span><br><span class=\"line\">iter += n;</span><br><span class=\"line\">iter +=iter2;</span><br></pre></td></tr></table></figure>\n<p><mark>判断vector非空</mark></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(v.<span class=\"built_in\">begin</span>() != v.<span class=\"built_in\">end</span>());</span><br></pre></td></tr></table></figure>\n<p>和指针类似, 迭代器分类型,也有const类型</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector &lt;<span class=\"type\">int</span>&gt;::iterator it;</span><br><span class=\"line\">vector &lt;<span class=\"type\">int</span>&gt;::const_iterator it;</span><br></pre></td></tr></table></figure>\n<p>类似的const_iterator只能读</p>\n<p>一下表达等价</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">*(it).<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">it-&gt;empty;</span><br></pre></td></tr></table></figure>\n<p>☆使用了迭代器后不要增删原容器内容,因为他们会重新分配内存</p>\n<h2 id=\"vector多维数组\"><a href=\"#vector多维数组\" class=\"headerlink\" title=\"vector多维数组\"></a>vector多维数组</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt; &gt; <span class=\"built_in\">array</span>(m); <span class=\"comment\">//m*m</span></span><br><span class=\"line\"><span class=\"comment\">//初始化一个m*n的二维数组</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;m;i++) &#123;</span><br><span class=\"line\">    array[i].<span class=\"built_in\">resize</span>(n);</span><br><span class=\"line\">&#125;<span class=\"comment\">//本质上可以长短不一</span></span><br><span class=\"line\"><span class=\"comment\">//遍历赋值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; array.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; array[<span class=\"number\">0</span>].<span class=\"built_in\">size</span>();j++) &#123;</span><br><span class=\"line\">        array[i][j] = i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"type\">const</span> vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; &amp;vec)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> c : vec) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> s : c )&#123;</span><br><span class=\"line\">            cout &lt;&lt; s &lt;&lt;<span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout&lt;&lt;endl;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">0</span> </span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">2</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"comment\">//本质上变成这样也是一样的无非是显示方式</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>(m)内外都设置为m大小</li>\n<li>resize(n)</li>\n<li>array.size()行数—-array[0].size()列数</li>\n</ol>\n<p>所谓行列本质上没有意义,真正只有内外之分,无非是显示函数怎么写</p>\n<p>我们可以做出规定,为了写着方便认为—外层向下竖着排内层向横向展开</p>\n<p>这样既一个是行一个是列</p>\n<h1 id=\"显示类型转换\"><a href=\"#显示类型转换\" class=\"headerlink\" title=\"显示类型转换\"></a>显示类型转换</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">cast-<span class=\"built_in\">name</span>&lt;type&gt;(expression)</span><br></pre></td></tr></table></figure>\n<p>cast-name 有四种</p>\n<p>static_cast/dynamic_cast/const_cast/reinterpret_cast</p>\n<ul>\n<li><p>static_cast可以常用,但是不能改const</p>\n</li>\n<li><p>const_cast只能用作去const,不能改类型</p>\n</li>\n<li><p>其他两个暂不了解也不需要使用</p>\n</li>\n</ul>\n","categories":["日志"],"tags":["c++语法","string","vector"]},{"title":"day4-学习总结","url":"/2022/03/01/day4-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>光纤进展-思路受阻没有确切的目标</p>\n<p>函数传参和返回值,与指针引用的结合</p>\n<p>螺旋阅读法</p>\n<span id=\"more\"></span>\n<h1 id=\"函数传形参\"><a href=\"#函数传形参\" class=\"headerlink\" title=\"函数传形参\"></a>函数传形参</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reset</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span> &amp;vec)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>复习一下引用的定义方式</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> &amp;r = n;<span class=\"comment\">//r是n的别名</span></span><br></pre></td></tr></table></figure>\n<p>type &amp; 理解为引用类型</p>\n<p>const可以有效减少复杂数据结构的复制开销</p>\n<p>另外,如果不使用const引用,则普通的引用无法接受字面值,因为无法将const变量赋予一个非const引用</p>\n<h2 id=\"传递数组\"><a href=\"#传递数组\" class=\"headerlink\" title=\"传递数组\"></a>传递数组</h2><p>数组是不允许拷贝的,而且当我们传递时他会退化为指针</p>\n<p>int* 与int[]是完全不一致的</p>\n<p>所以我们传递数组时要想办法告诉函数他的范围</p>\n<p>传递数组的引用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> (&amp;arr)[<span class=\"number\">10</span>])</span></span>&#123;;&#125;<span class=\"comment\">//数组的引用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> &amp;arr[<span class=\"number\">10</span>])</span></span>&#123;;&#125;<span class=\"comment\">//包含10个引用的数组,并不存在这种东西</span></span><br></pre></td></tr></table></figure>\n<p>我们复习数组的定义规则: arr是名称声明,[]是修饰, <mark>*/&amp;的运算优先级是最低的</mark>所以</p>\n<h1 id=\"螺旋阅读法\"><a href=\"#螺旋阅读法\" class=\"headerlink\" title=\"螺旋阅读法\"></a>螺旋阅读法</h1><p>我们理解数组的声明分为三个部分,自身标识符,维度,内部数据类型</p>\n<p><code>int&amp; arr[10]</code>就可以直接看出&amp;不属于标识符而是内部数据类型</p>\n<p>由内而外的螺旋读法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> *(&amp;arr)[<span class=\"number\">10</span>];</span><br></pre></td></tr></table></figure>\n<p>首先,我们看未明确标识符arr,看到&amp;可以知道arr是一个引用</p>\n<p>然后右边,我们看到他是一个大小为10的数组的引用</p>\n<p>最后左边,我们知道数组的元素类型是int*</p>\n<p>所以这是一个含有10个int型指针的数组的引用</p>\n<p>我们复习一下指针和引用的声明:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>* ptr = &amp;i;<span class=\"comment\">//ptr是一个指向i的指针, &amp;在这里是取地址</span></span><br><span class=\"line\"><span class=\"type\">int</span> &amp;ref = *ptr;<span class=\"comment\">//这里的*表示解引用,不可和上面混淆,所以ref是i的引用</span></span><br><span class=\"line\"><span class=\"type\">int</span>* &amp;refptr = ptr;<span class=\"comment\">//refptr是ptr的引用</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"函数返回引用为左值\"><a href=\"#函数返回引用为左值\" class=\"headerlink\" title=\"函数返回引用为左值\"></a>函数返回引用为左值</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> &amp; <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> &amp;arr, <span class=\"type\">int</span> ix)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> &amp;arr[ix];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> main&#123;</span><br><span class=\"line\">    <span class=\"comment\">//定义略</span></span><br><span class=\"line\">    <span class=\"built_in\">func</span>(arr, ix) = <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>func返回了一个引用, 这个返回值是一个左值(<mark>其余类型返回量都为右值</mark>)</p>\n<p>我们可以对这个返回量直接进行修改</p>\n<p>在例子中,我们知道func接受了非const int数组,函数体中的arr仍然是原址的,又返回了arr一个位置的引用,那么对返回引用的修改,直接作用于了main中的arr.</p>\n<p>但是我们函数传参传过去非引用的话,这种行为是要绝对禁止的,因为复制后的地址会被销毁,会造成严重错误</p>\n<h1 id=\"尾置返回类型\"><a href=\"#尾置返回类型\" class=\"headerlink\" title=\"尾置返回类型\"></a>尾置返回类型</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> (*<span class=\"built_in\">func</span>(<span class=\"type\">int</span> i))[<span class=\"number\">10</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> -&gt; <span class=\"title\">int</span> <span class=\"params\">(*)</span> [10]</span>&#123;&#125;;<span class=\"comment\">//等价</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>&#123;;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">func</span><span class=\"params\">()</span> -&gt;<span class=\"type\">int</span></span>&#123;;&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h1><p>三个部分,原函数的返回值,(*func),参数类型列表.这些形状都一样的函数的指针也是一样的类型即使名字不同</p>\n<p>如 </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> ptr = <span class=\"built_in\">int</span> (*func)(<span class=\"type\">int</span>, <span class=\"type\">int</span>*);</span><br></pre></td></tr></table></figure>\n<p>自然我们可以用传指针和返回指针</p>\n<p>推荐尾置写法写返回函数指针</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> (*<span class=\"built_in\">getfunc</span>(string))(<span class=\"type\">int</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">getfunc</span><span class=\"params\">(string)</span> -&gt; <span class=\"title\">int</span> <span class=\"params\">(*)</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span>;<span class=\"comment\">//等价</span></span><br></pre></td></tr></table></figure>\n<p>也可以使用decltype</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">decltype</span>(func) * <span class=\"built_in\">getfunc</span>(string)&#123;&#125;;<span class=\"comment\">//返回func函数指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(func) &amp; <span class=\"built_in\">getfunc</span>(string)&#123;&#125;;<span class=\"comment\">//返回func函数的引用</span></span><br><span class=\"line\"><span class=\"keyword\">decltype</span>(func) <span class=\"built_in\">getfunc</span>(string)&#123;&#125;;<span class=\"comment\">//返回func函数的类型</span></span><br></pre></td></tr></table></figure>\n","categories":["日志"]},{"title":"day5-学习总结","url":"/2022/03/02/day5-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","content":"<p>类的书写规则,构造函数,静态成员,this指针</p>\n<span id=\"more\"></span>\n<h1 id=\"类的书写规则\"><a href=\"#类的书写规则\" class=\"headerlink\" title=\"类的书写规则\"></a>类的书写规则</h1><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Stack</span>&#123;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> Stack&amp;)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">friend</span> returnType <span class=\"title\">somefunc</span><span class=\"params\">(Type)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//友元,做声明的外部函数可以访问private</span></span><br><span class=\"line\"><span class=\"keyword\">friend</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Stack_friend</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">const</span> string&amp;)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> _stack.<span class=\"built_in\">size</span>();&#125;<span class=\"comment\">//内联函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">double</span> interrate;<span class=\"comment\">//非const静态成员,必须在外部初始化</span></span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">const</span> <span class=\"type\">double</span> const_interrate = <span class=\"number\">2</span>;<span class=\"comment\">//const可以类内声明+初始化(c++11)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">double</span> <span class=\"title\">rate</span><span class=\"params\">()</span></span>&#123;<span class=\"keyword\">return</span> interrate;&#125;<span class=\"comment\">//不传递this指针</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">void</span> <span class=\"title\">rate</span><span class=\"params\">(<span class=\"type\">double</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Stack</span>(vector&lt;string&gt;);<span class=\"comment\">//构造函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    vector&lt;string&gt; _stack = &#123;<span class=\"string\">&quot; &quot;</span>&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Stack::<span class=\"built_in\">Stack</span>(vector&lt;string&gt; _stack)&#123;</span><br><span class=\"line\">    _stack = &#123;<span class=\"string\">&quot;null&quot;</span>&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//或者可以使用成员初始化列表</span></span><br><span class=\"line\">Stack::<span class=\"built_in\">Stack</span>(Stack &amp; rhs): _stack(rhs._stack)&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Stack::push</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; elem)</span></span>&#123;</span><br><span class=\"line\">    _stack.<span class=\"built_in\">push_back</span>(elem);</span><br><span class=\"line\">    <span class=\"type\">double</span> rate = interrate;<span class=\"comment\">//直接访问静态成员</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"type\">const</span> Stack&amp; v)</span></span>&#123;...&#125;<span class=\"comment\">//外部函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> Stack::interrate = <span class=\"number\">0.1</span>;<span class=\"comment\">//必须在外部声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Stack::rate</span><span class=\"params\">(<span class=\"type\">double</span> newrate)</span></span>&#123;</span><br><span class=\"line\">    interrate = newrate;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//外部访问静态成员</span></span><br><span class=\"line\"><span class=\"type\">double</span> rate = Stack::rate;</span><br><span class=\"line\">Stack ac1;ac1-&gt;<span class=\"built_in\">rate</span>();</span><br></pre></td></tr></table></figure>\n<h1 id=\"this指针\"><a href=\"#this指针\" class=\"headerlink\" title=\"this指针\"></a>this指针</h1><p>this指针在成员函数中用作指向调用者(对象)本身, 在调用时隐式的传递给了成员函数</p>\n<p>this是一个const指针,不允许改变本身所储存的地址,当然地址指向的位置是否可以改变(底层const)由自身决定</p>\n<p>这样我们就不能将一个普通的this绑定到一个const对象上,这样const对象是不能调用非const函数的</p>\n<p>所以我们可以const修饰this指针</p>\n<h2 id=\"我们复习一下常量指针\"><a href=\"#我们复习一下常量指针\" class=\"headerlink\" title=\"我们复习一下常量指针:\"></a>我们复习一下常量指针:</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> ival = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> *ptr = &amp;ival;<span class=\"comment\">//ptr指向const int型,而地址本身是可变的</span></span><br><span class=\"line\"><span class=\"type\">int</span> *<span class=\"type\">const</span> ptr = &amp;ival;<span class=\"comment\">//错误的,ptr是一个指向非常量的常量指针</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> *<span class=\"type\">const</span> ptr = &amp;ival;<span class=\"comment\">//ptr存储地址本身不可变,也指向cosnt</span></span><br></pre></td></tr></table></figure>\n<p>我们称ptr本身不可变为顶层const,指向的类型为const为底层const,二者无任何关系</p>\n<p>回到this的问题上,this默认是顶层const的,要修饰为底层const以指向const对象:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">func</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;&#125;; </span><br></pre></td></tr></table></figure>\n<p>也可以称为常量成员函数</p>\n<h2 id=\"返回this\"><a href=\"#返回this\" class=\"headerlink\" title=\"返回this\"></a>返回this</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">className&amp; <span class=\"title\">className::func</span><span class=\"params\">()</span></span>&#123;<span class=\"comment\">//返回引用类型,而且是一个左值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>很明显一个const成员函数将会返回const型引用,因为const修饰了this,其底层也是const的</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> className&amp; <span class=\"title\">className::func</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>&#123;<span class=\"comment\">//返回常量引用类型</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"构造函数-成员初始化列表\"><a href=\"#构造函数-成员初始化列表\" class=\"headerlink\" title=\"构造函数-成员初始化列表\"></a>构造函数-成员初始化列表</h1><p>如上文有两种初始化形式,两种是可以混用的</p>\n<p>此外类内直接进行初始化也是可行的,构造函数会进行覆盖</p>\n<ul>\n<li><p>成员初始化列表可以初始化一些对象,也就是说类内嵌套着别的类,函数体内赋值是不能初始化的,尤其要注意<mark>string</mark></p>\n</li>\n<li><p>类中的<mark>const成员变量</mark>都要放在初始化列表之中进行</p>\n</li>\n</ul>\n<p>构造函数可以根据参数列表重构</p>\n<h1 id=\"mutable与const\"><a href=\"#mutable与const\" class=\"headerlink\" title=\"mutable与const\"></a>mutable与const</h1><p>用mutable修饰的数据成员,在任何时候(即使是const对象或是const函数中,都是可以改变它的)</p>\n<p>关于const可以修饰的类型:</p>\n<p>this指针(成员函数)/实例对象/类成员</p>\n<p>1）<strong>const成员函数</strong>可以访问<strong>非const对象的所有数据成员</strong>，也可以访问const对象内的所有数据成员；</p>\n<p>2）<strong>非const成员函数</strong>可以访问<strong>非const对象的所有数据成员</strong>，但<mark>不可以访问<em>const对象的任意数据成员</em></mark>；</p>\n<p><mark>反过来说, 非const对象可以访问任意成员函数,const对象只能访问const函数</mark></p>\n<p>3）同时出现时，非const对象优先调用非const成员函数。</p>\n<h1 id=\"基于const的二层重载\"><a href=\"#基于const的二层重载\" class=\"headerlink\" title=\"基于const的二层重载\"></a>基于const的二层重载</h1><p>我们经常需要一个const一个非const成员函数用于重载,但是显然我们不想写两遍</p>\n<p>那么两个函数同时引用一个private函数即可</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">screen</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">screen &amp; <span class=\"title\">display</span><span class=\"params\">(std::ostream &amp;os)</span></span></span><br><span class=\"line\"><span class=\"function\">    \t</span>&#123;<span class=\"built_in\">do_display</span>(os);<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> screen &amp; <span class=\"title\">display</span><span class=\"params\">(std::ostream &amp;os)</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    \t</span>&#123;<span class=\"built_in\">do_display</span>(os);<span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;&#125;    </span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">do_display</span><span class=\"params\">(std::ostream &amp;os)</span> <span class=\"type\">const</span> \t\t\t\t\t</span>&#123;os&lt;&lt;contents;&#125;<span class=\"comment\">//可以一次性修改实现</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样还可以解决另一个const问题:</p>\n<p>display()函数自然是不希望改变输入的,因此我们想到将其声明为const,但是同时我们希望他的返回*this不要是const的,这样普通的一层const是无法做到的</p>\n<p>因此我们嵌套了两层,第一层逻辑上只做调用第二层实现函数.第二层是const的</p>\n<p>我们观察:</p>\n<p>1) 当一个非const对象调用display时,将调用非常量的函数且返回一个非常量的引用;但是do_display将会<strong>接受this指针;然后将指针隐式转换为const</strong></p>\n<p>2) 当一个const对象调用display,只能调用常量函数且返回常量引用;do_display也将接受常量this指针<br>3) 最终,将会获得与对象类型一致的返回类型且实现内部都是const的;并且不需要多处复制修改</p>\n<h1 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h1><p>如果一个类中说明了静态数据成员，只有在这个类的第一个对象被创建时被初始化，自第二个对象起均不作初始化。</p>\n<p><strong>静态函数仅可以访问静态成员，或是静态成员函数或是静态数据成员。</strong>类的非静态成员函数却可以调用静态成员函数。</p>\n<p>静态数据成员可以在内部也可以在外部初始化,但是必须在类外部进行声明</p>\n<p>我们可以不依靠任何对象的使用静态成员函数/数据</p>\n","categories":["日志"]},{"title":"Hello World","url":"/2022/02/24/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"markdown","url":"/2022/02/24/markdown/","content":"<h1 id=\"markdown\"><a href=\"#markdown\" class=\"headerlink\" title=\"markdown\"></a>markdown</h1><p><strong>加粗</strong></p>\n<p><em>倾斜</em></p>\n<p><u>下划线</u></p>\n<p>==高亮==</p>\n<p>cm^3^</p>\n<p>H~2~O</p>\n<span id=\"more\"></span>\n<h2 id=\"列表：\"><a href=\"#列表：\" class=\"headerlink\" title=\"列表：-\"></a>列表：-</h2><ul>\n<li>1<ul>\n<li>1.1<ul>\n<li>1.1.1<ul>\n<li>1.1.1.1</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2</li>\n</ul>\n<p>有序列表：1.</p>\n<ol>\n<li>第一<ol>\n<li>不能二级</li>\n</ol>\n</li>\n<li>第二</li>\n<li>第三</li>\n</ol>\n<p>待办事项：</p>\n<ul>\n<li>[ ] 干活</li>\n</ul>\n<h2 id=\"行内代码：int整形\"><a href=\"#行内代码：int整形\" class=\"headerlink\" title=\"行内代码：int整形\"></a>行内代码：<code>int</code>整形</h2><p>代码块：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> main</span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">我</th>\n<th style=\"text-align:center\"></th>\n<th style=\"text-align:right\"></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\">你</td>\n<td style=\"text-align:right\"></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:right\">地方</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p>我没说过-鲁迅<sup><a href=\"#fn_1\" id=\"reffn_1\">1</a></sup></p>\n</blockquote>\n<p>哔站是<a href=\"https://www.bilibili.com\">bilibili</a></p>\n<p>跳转<a href=\"#markdown\">一级标题</a>小括号内是#加完全一致的内容</p>\n<h2 id=\"插入图片picgo\"><a href=\"#插入图片picgo\" class=\"headerlink\" title=\"插入图片picgo\"></a>插入图片picgo</h2><p><img src=\"https://s2.loli.net/2022/02/24/qPZwiMHbBstfojU.png\" style=\"zoom:33%;\" /></p>\n<blockquote id=\"fn_1\">\n<sup>1</sup>. 我自己说的<a href=\"#reffn_1\" title=\"Jump back to footnote [1] in the text.\"> &#8617;</a>\n</blockquote>\n<p>分割线</p>\n<hr>\n","categories":["Hexo"],"tags":["markdown","学习"]}]